Section 1.1  Information Is Bits + Context

Our hello program begins life as a source program (or source ﬁle) that the programmer creates with an editor and saves in a text ﬁle called hello.c. The source program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks called bytes. Each byte represents some text character in the program. MostmodernsystemsrepresenttextcharactersusingtheASCIIstandardthat represents each character with a unique byte-sized integer value. For example, Figure 1.2 shows the ASCII representation of the hello.c program. The hello.c program is stored in a ﬁle as a sequence of bytes. Each byte has an integer value that corresponds to some character. For example, the ﬁrst byte has the integer value 35, which corresponds to the character ‘#’. The second byte hastheintegervalue105,whichcorrespondstothecharacter‘i’,andsoon.Notice that each text line is terminated by the invisible newline character ‘\n’, which is representedbytheintegervalue10.Filessuchas hello.c thatconsistexclusively of ASCII characters are known as text ﬁles. All other ﬁles are known as binary ﬁles. Therepresentationofhello.cillustratesafundamentalidea:Allinformation in a system—including disk ﬁles, programs stored in memory, user data stored in memory,anddatatransferredacrossanetwork—isrepresentedasabunchofbits. The only thing that distinguishes different data objects is the context in which we view them. For example, in different contexts, the same sequence of bytes might represent an integer, ﬂoating-point number, character string, or machine instruction. Asprogrammers,weneedtounderstandmachinerepresentationsofnumbers because they are not the same as integers and real numbers. They are ﬁnite approximations that can behave in unexpected ways. This fundamental idea is explored in detail in Chapter 2.

Aside
Origins of the C programming languageC was developed from 1969 to 1973 by Dennis Ritchie of Bell Laboratories. The American NationalStandards Institute (ANSI) ratified the ANSI C standard in 1989, and this standardization later becamethe  responsibility  of  the  International  Standards  Organization  (ISO).  The  standards  define  the  Clanguage and a set of library functions known as theC standard library. Kernighan and Ritchie describeANSI C in their classic book, which is known affectionately as “K&R” [58]. In Ritchie’s words [88], Cis “quirky, flawed, and an enormous success.” So why the success?.C was closely tied with the Unix operating system.C was developed from the beginning as thesystem programming language for Unix. Most of the Unix kernel, and all of its supporting toolsand libraries, were written in C. As Unix became popular in universities in the late 1970s and early1980s, many people were exposed to C and found that they liked it. Since Unix was written almostentirely in C, it could be easily ported to new machines, which created an even wider audience forboth C and Unix..C is a small, simple language.The design was controlled by a single person, rather than a committee,and the result was a clean,  consistent design with little baggage. The K&R book describes thecomplete language and standard library, with numerous examples and exercises, in only 261 pages.The simplicity of C made it relatively easy to learn and to port to different computers..C was designed for a practical purpose.C was designed to implement the Unix operating system.Later, other people found that they could write the programs they wanted, without the languagegetting in the way.C  is  the  language  of  choice  for  system-level  programming,  and  there  is  a  huge  installed  base  ofapplication-level programs as well. However, it is not perfect for all programmers and all situations.C pointers are a common source of confusion and programming errors. C also lacks explicit supportfor useful abstractions such as classes, objects, and exceptions. Newer languages such as C++ and Javaaddress these issues for application-level programs

Section 1.2  Programs Are Translated by Other Programs into Different Forms

The hello program begins life as a high-level C program because it can be readand understood by human beings in that form. However, in order to runhello.con the system, the individual C statements must be translated by other programsinto a sequence of low-levelmachine-languageinstructions. These instructions arethen packaged in a form called anexecutable object programand stored as a binarydisk file. Object programs are also referred to asexecutable object files.On a Unix system, the translation from source file to object file is performedby acompiler driver:unix>gcc -o hello hello.c

Here, the gcc compiler driver reads the source filehello.cand translates it intoan  executable  object  filehello.  The  translation  is  performed  in  the  sequenceof four phases shown in Figure 1.3. The programs that perform the four phases(preprocessor,compiler,assembler,  andlinker)  are  known  collectively  as  thecompilation system..Preprocessing phase.The preprocessor (cpp) modifies the original C programaccording  to  directives  that  begin  with  the#character.  For  example,  the#include <stdio.h>command in line 1 ofhello.ctells the preprocessorto read the contents of the system header filestdio.hand insert it directlyinto the program text. The result is another C program, typically with the.isuffix..Compilation phase.The compiler (cc1) translates the text filehello.iintothe text filehello.s,  which contains anassembly-language program. Eachstatement in an assembly-language program exactly describes one low-levelmachine-language instruction in a standard text form. Assembly language isuseful because it provides a common output language for different compilersfor  different  high-level  languages.  For  example,  C  compilers  and  Fortrancompilers both generate output files in the same assembly language..Assembly phase.Next, the assembler (as) translateshello.sinto machine-language instructions, packages them in a form known as arelocatable objectprogram, and stores the result in the object filehello.o.Thehello.ofile isa binary file whose bytes encode machine language instructions rather thancharacters. If we were to viewhello.owith a text editor, it would appear tobe gibberish..Linking phase.Notice that ourhelloprogram calls theprintffunction, whichis part of thestandard C libraryprovided by every C compiler. Theprintffunction resides in a separate precompiled object file calledprintf.o, whichmust somehow be merged with ourhello.oprogram. The linker (ld) handlesthis merging. The result is thehellofile, which is anexecutable object file(orsimplyexecutable) that is ready to be loaded into memory and executed bythe system.

AsideThe GNU projectGCCis one of many useful tools developed by the GNU (short for GNU’s Not Unix) project. TheGNU project is a tax-exempt charity started by Richard Stallman in 1984, with the ambitious goal ofdeveloping a complete Unix-like system whose source code is unencumbered by restrictions on howit can be modified or distributed. The GNU project has developed an environment with all the majorcomponents of a Unix operating system, except for the kernel, which was developed separately bythe Linux project. The GNU environment includes theemacseditor,gcccompiler,gdbdebugger,assembler,  linker,  utilities  for  manipulating  binaries,  and  other  components.  Thegcccompiler  hasgrown  to  support  many  different  languages,  with  the  ability  to  generate  code  for  many  differentmachines. Supported languages include C, C++, Fortran, Java, Pascal, Objective-C, and Ada.The GNU project is a remarkable achievement, and yet it is often overlooked. The modern open-source movement (commonly associated with Linux) owes its intellectual origins to the GNU project’snotion offree software(“free” as in “free speech,” not “free beer”). Further, Linux owes much of itspopularity to the GNU tools, which provide the environment for the Linux kernel.



