###4.4. Design Patterns
So, what exactly qualifies a language as being object oriented (OO)?
如何定义一个语言是面向对象的语言呢

Some people believe that any language that has objects that encapsulate data and methods can be considered OO. 
有人认为有对象实例包含数据和方法可以称为面向对象

Others would also include polymorphism via inheritance and access modifiers into the definition. 
The purists would probably list dozens of pages of things they think an OO language must support, 
such as exceptions, method overloading, reflection, strict typing, and more. 
You can bet that none of these people would ever agree with each other because of the diversity of OOP languages, 
each of them good for certain tasks and not quite as good for others.
有人认为多态，继承，异常，方法重载，强类型的才叫面向对象


However, what most people would agree with is that developing OO software is not only about the syntax and the language features 
but it is a state of mind. 
Although there are some professionally written programs in functional languages such as C (for example, PHP)
, people developing in OO languages tend to give the software design more of an emphasis.
One reason might be the fact that OO languages tend to contain features that help in the design phase, 
but the main reason is probably cultural because the OO community has always put a lot of emphasis on good design.
可以使用设计模式的更常定义为面向对象

This chapter covers some of the more advanced OO techniques that are possible with PHP, 
including the implementation of some common design patterns that are easily adapted to PHP.

When designing software, certain programming patterns repeat themselves. 
Some of these have been addressed by the software design community and have been given accepted general solutions. 
These repeating problems are called design patterns. 
The advantage of knowing and using these patterns is not only to save time instead of reinventing the wheel, 
but also to give developers a common language in software design. 
使用设计模式避免重造轮子
You'll often hear software developers say, "Let's use a singleton pattern for this," or "Let's use a factory pattern for that." 
Due to the importance of these patterns in today's software development, this section covers some of these patterns.
更好的与别人沟通


###4.4.1. Strategy Pattern 


策略模式
The strategy pattern is typically used when your programmer's algorithm should be interchangeable with different variations of the algorithm. 
For example, if you have code that creates an image, under certain circumstances, 
you might want to create JPEGs and under other circumstances, you might want to create GIF files.

The strategy pattern is usually implemented by declaring an abstract base class with an algorithm method,
策略模式常常继承抽象类,实现相应的方法
which is then implemented by inheriting concrete classes. 
At some point in the code, it is decided what concrete strategy is relevant; 
it would then be instantiated and used wherever relevant.


The strategy pattern is often used with the factory pattern, which is described later in this section. The factory pattern selects the correct strategy.
策略模式通常和工厂模式一起使用,工厂模式选择正确的策略

```php
abstract class FileNamingStrategy {
    abstract function createLinkName($filename);
}

class ZipFileNamingStrategy extends FileNamingStrategy {
    function createLinkName($filename)
    {
        return "http://downloads.foo.bar/$filename.zip";
    }
}

class TarGzFileNamingStrategy extends FileNamingStrategy {
    function createLinkName($filename)
    {
        return "http://downloads.foo.bar/$filename.tar.gz";
    }
}

if (strstr($_SERVER["HTTP_USER_AGENT"], "Win")) {
    $fileNamingObj = new ZipFileNamingStrategy();
} else {
    $fileNamingObj = new TarGzFileNamingStrategy();
}

$calc_filename = $fileNamingObj->createLinkName("Calc101");
$stat_filename = $fileNamingObj->createLinkName("Stat2000");
```

###4.4.2. Singleton Pattern
The singleton pattern is probably one of the best-known design patterns. 
单例模式是最常见的设计模式
You have probably encountered遇到 many situations where you have an object that handles some centralized集中 operation in your application, 
需要一个集中操作的对象，不用每次都实例化
such as a logger object. In such cases, 
it is usually preferred for only one such application-wide instance to exist and for all application code to have the ability to access it.
只有一个实例在应用里访问
Specifically, in a logger object, you would want every place in the application that wants to print something to the log to have access to it, 
and let the centralized logging mechanism handle the filtering of log messages according to log level settings. 
For this kind of situation, the singleton pattern exists.

Making your class a singleton class is usually done by implementing a static class method getInstance(),
which returns the only single instance of the class.
单例模式的类一般使用静态方法 getInstance();用来返回类的实例
The first time you call this method, it creates an instance, 
saves it in a private static variable, 
and returns you the instance. 
访问这个静态方法，创建一个实例，保存到私有静态变量中
The subsequent随后 times, 
it just returns you a handle to the already created instance.
返回已经创建好的实例

The essence of this pattern is Logger::getInstance(),
which gives you access to the logging object from anywhere in your application, 
whether it is from a function, a method, or the global scope.
无论从方法还是全局访问，都会返回相同的

In this example, the constructor and clone methods are defined as private.
初始化和克隆的方法定义为私有方法
This is done so that a developer can't mistakenly create a second instance of the Logger class using the new or clone operators;
使无法通过new和克隆来创建新的对象
therefore, getInstance() is the only way to access the singleton class instance.
getInstance是唯一能访问这个实例的方法

Here's an example:
```php
class Logger {
    static function getInstance()
    {
        if (self::$instance == NULL) {
            self::$instance = new Logger();
        }
        return self::$instance;
    }
    
    //把构造函数声明为 protected，防止用 `new` 操作符在这个类之外创建新的实例
    private function __construct()
    {
    }

    //设置为私有方法，防止进行克隆
    private function __clone()
    {

    }

    function Log($str)
    {
        // Take care of logging
    }

    static private $instance = NULL;
}

Logger::getInstance()->Log("Checkpoint");
```



 
