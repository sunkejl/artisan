函数 function
完成特定任务的独立代码单元

递归
recursion
简洁 但效率没有循环高

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）
如果return 返回函数 就不创造新的stack
但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误

尾递归
tail recursion

一般而言，选择循环比较好
首先，每次递归都会创建一组变量，所以递归使用的内存更多
而且每次递归调用都会把创建的一组新变量放在栈中
递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢
因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归
因此还是要好好理解递归

十进制转换2进制
不停的/2 记录余数

递归 快速消耗内存资源


&   一元运算符
pointer 指针 用于存储变量地址

a是变量名 &a是变量地址

每个16进制数 对应4个位 bit
ff 对应 1111 1111

指针 是一个值为内存地址的变量

char类型的变量的值是字符
int类型的变量值是整数
指针变量的值是地址

* 间接运算符 indirection operator
解引用运算符 dereferencing operator

&给出变量的地址
*给出指针指向地址上的值 go to

声明指针变量必须指定执政指向的变量的类型
不同的变量类型占用不同的存储空间

int *pi
pi是一个指针 *pi是int类型

指针是单独的类型 不是整数类型

代码中 变量有俩个属性 名称和值
编译后 变量也有俩个属性 地址和值 地址是变量在计算机内部的名称

```
 #include<stdio.h>
 void f(int *a){
     *a=1;
 }
 void main(){
     int a=123;
     f(&a);
     printf("%d",a);
 }
```
