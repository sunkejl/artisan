C提供了结构变量（structure variable）提高表示数据的能力

```
  1 #include <stdio.h>
  2 struct k{
  3     int i;
  4     char *j;
  5 };
  6 void main(){
  7     struct k s;
  8     s.i=1;
  9     s.j="ccc";
 10 }

```
结构中的每个部分称为成员 member 或者 字段 field

结构体声明 structure declaration

struct声明并未创建实际的数据对象，只描述了该对象由什么组成
有时，我们把结构声明称为模板，因为它勾勒出结构是如何储存数据的

声明结构数组
struct book library[10];
library 含有10个结构为book的数组

使用指向结构的指针
第一，就像指向数组的指针比数组本身更容易操控（如，排序问题）一样
指向结构的指针通常比结构本身更容易操控。

第二，在一些早期的C实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。

第三，即使能传递一个结构，传递指针通常更有效率。

第四，一些用于表示数据的结构中包含指向其他结构的指针。

struct k *s;
s是指向结构的指针

指针访问成员
s->name 就是struct.name
为什么不能写成s.name 因为s不是结构体

向函数传递结构
1 传递结构成员
sum(s.price);
function s(double p){
}
2传递结构地址
sum(&s);
function s(struct k *s){
}
3传递结构体
sum(s);
function s(struct k s){
}

结构体可以复制
数组不可以复制


把指针作为参数有两个优点：无论是以前还是现在的C实现都能使用这种方法，而且执行起来很快，只需要传递一个地址。缺点是无法保护数据。被调函数中的某些操作可能会意外影响原来结构中的数据。不过，ANSIC新增的const限定符解决了这个问题。

把结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护了原始数据。另外，代码风格也更清楚

结构体中使用*s地址变量来存储字符串
由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方
如果走运的话，程序不会出问题，至少暂时不会出问题，否则这一操作会导致程序崩溃

要解决字符串未被初始化 可以用malloc
```
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 void main (){
  4     char *p;
  5     p=(char *) malloc(6*sizeof(char));
        scanf("%s",p);
  8     printf("%s",p);
        free(p);
  9 }

```
malloc 和free 要成对出现

包括队列、二叉树、堆、哈希表和图表都由链式结构（linked structure）组成
每个结构都包含一两个数据项和一两个指向其他同类型结构的指针
这些指针把一个结构和另一个结构链接起来，并提供一种路径能遍历整个彼此链接的结构

联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）
其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型
使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。


