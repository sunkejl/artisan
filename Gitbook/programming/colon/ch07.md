抽象封装

抽象思维

不独计算机领域，其他科学领域乃至艺术领域同样需要这种能力。更广泛地说，抽象是人类认识和描绘世界最首要的工具。

去粗取精以化繁为简；
由表及里以异中求同。

抽象就是作减法和除法。

相同的实体（entity）经过不同角度的抽象，得到的模型（model）也会不同。

软件设计者的任务是将复杂混沌的现实世界映射到精确严格的虚拟世界，
要完成这种多对一的映射，抽象无疑是必由之路。

在软件工程中，尽管系统开发生命周期（Systems Development Life Cycle，简称SDLC）
按照不同的模型有不同的阶段划分，
但最核心的三个阶段——
分析（analysis）、设计（design）和实现（implementation）总是必不可少的。

其中，分析阶段的主要任务是在
理解问题领域（problem domain）和明确业务需求（business requirement）的基础上制定出功能规范（functional specification）
设计阶段的主要任务是在分析的基础上制定出实现规范（implementation specification）
实现阶段则在设计的基础上完成软件编码。
如果采用对象导向式（OO）的方法，
则相对应的便是OOA（Object-Oriented Analysis）、OOD（Object-Oriented Design）和OOP（Object-Oriented Programming）。

具体到实际编程，常用两种抽象机制：
一种是参数抽象（abstraction by parameterization），一种是规范抽象（abstraction by specification）

参数抽象是不是指将函数的实现代码中一些特殊值作为参数来传递

没有文档的API如同没有说明书的产品，除了实现者本人，其他用户是不敢轻易调用的。

合格的文档注释中至少应包括先验条件（pre condition）和后验条件（post condition），分别指代码执行前后必须满足的条件

有了文档注释或规范说明（specification）的函数成为使用者与实现者之间的一种契约
只要使用者提出满足规范的请求，实现者一定提供满足规范的服务
这种通过规范使代码的功能与实现相分离的方法便称为规范抽象，它规范了服务提供方的义务，同时保障了服务享受方的权利。

说明性的文档规范有两个弱点：
一是自然语言不够精确；
二是不能确保规范的实施。

编程设计方法——契约式设计（Design by Contract，简称DbC）不仅可以解决上述两个问题，在OOP中还有额外的意义。
例如，契约是可继承的，即契约对子类仍然有效；
契约能从方法（method）级别扩大到类（class）级别
类不变量（class invariant）保证一个对象状态的某些限定条件永远不会被违反
这些都有效地保障了软件的可靠性。

防御性编程（defensive programming），其目的是维护代码安全。
如果遭遇意外的输入，一般会尽可能地作妥善处理，
必要时返回错误代码或抛出异常转交客户处理。
但凡有经验的程序员都很熟悉这种方法，
不过它的缺陷也很明显：

一是导致先验条件的重复检查。
比如函数已经检查了一个参数的合法性，
当该函数把该参数继续传入另一个函数时，后者很可能还要对它检查一遍，
既增加了代码冗余，又降低了程序效率。

二是增加程序员的负担和困惑。
很多时候他们难以选择处理非法参数的方案，
是返回错误代码，还是抛出异常？
若抛异常，又该抛哪种异常？
要写错误日志（error log）吗？

三是职责不明。究竟谁该保证先验条件的成立？
出了问题到底该追究谁的责任？又该如何追究？

说白了，防御性编程采取的是‘先小人后君子’的策略：
先不讲情面，对所有的客户请求进行例行检查，通过后才提供真正的服务。

契约式设计采取的是‘先君子后小人’的策略做法强调职责分明，
认为先验条件是客户方的责任，服务方无须过问。
倘若客户违约在先，将后果自负——或拒绝服务、或抛出异常、或中止系统、或废进废出（GarbageIn,GarbageOut）。
相比防御性编程的彼此戒备、互相提防，
契约式设计建立了更好的信用体制，因此更多的是彼此默契、互相信任。
二者虽有重合部分，但总体上是互补的，共同为软件的可靠性（reliability）提供保障。

前者重在保证软件的健壮性（robustness），适合应付无法防止或难以预测的异常；
后者重在保证软件的正确性（correctness），适合应付不应当发生的异常——代码中的缺陷。

契约式设计也称为契约式编程（Programming by Contract）
软件开发过程中的阶段之间的界限是很模糊的，尤其是设计与实现这两个阶段。

有人认为软件设计不应涉及任何语言和具体细节
有人则走另一极端，认为源代码就是设计，编译才是实现
还有的干脆以架构师为准：架构师干的部分是设计，不干的部分是实现

抽象的级别。抽象程度越高，越接近设计，越远离实现，相应的语言也越高级
另一方面，越是抽象的模型越不受细节的羁绊，因而稳定性越高，普适性越强，可重用性越高

参数抽象和规范抽象

借助这两种抽象机制，我们可以实现五类基本抽象：
过程抽象（procedural abstraction）
数据抽象（data abstraction）
迭代抽象（iteration abstraction）
类型层级（type hierarchy）
多态抽象（polymorphic abstraction）

过程抽象赋予程序员自定义运算（operation）的能力
数据抽象赋予程序员自定义类型（type）的能力
迭代抽象赋予程序员自定义循环（loop）的能力
类型层级赋予程序员自定义类族（type family）的能力
多态抽象赋予程序员自定义多态类型（polymorphic type）的能力。

过程抽象是过程范式的关键
泛型范式时提到的迭代器（iterator）便是迭代抽象的结果
类型层级涉及对象范式中的继承
多态抽象涉及对象范式与泛型范式中的多态
数据抽象，是OOP的起源

➢抽象是去粗取精以化繁为简、由表及里以异中求同，是对问题作减法和除法。

➢抽象既有角度之分，也有程度之别。

➢编程范式的风格差异和编程语言的级别高低，都取决于各自提供的抽象机制。

➢软件设计者利用抽象来完成从现实世界到虚拟世界的多对一映射。

➢在软件开发过程中，分析阶段的主要任务是在问题领域和业务需求的基础上制定功能规范；
设计阶段的主要任务是在分析的基础上制定实现规范；实现阶段则在设计的基础上完成软件编码。

➢抽象贯穿软件开发的核心过程：
分析阶段多采用性质导向式抽象；
设计阶段则多采用模型导向式抽象；
实现阶段多采用参数抽象和规范抽象

➢性质导向式抽象侧重于描述系统性质，因而是定性的，抽象程度较高
模型导向式侧重于建造数学模型，因而是定量的，抽象程度较低。

➢参数抽象增强了软件模块的普适性和重用性

➢规范抽象在使用者与实现者之间建立了一种契约，使代码的功能与实现相分离。
它一方面规范了实现者的义务，另一方面又保障了使用者的权利。
规范可以用通俗的自然语言在文档中注释，
也可以用精确的形式规范语言来表达

➢规范抽象的好处：
文档性——程序员不必阅读代码即可正确使用；
局部性——对某一抽象的实现代码的阅读或改写不会涉及其他抽象的实现；
可变性——修改实现代码不会影响其他代码。

➢先验条件是客户方的承诺，后验条件是服务方的承诺

➢防御性编程的缺陷：重复检查先验条件、增加程序员的负担和困惑、职责不清晰。

➢防御性编程一般处理难以防止或预测的异常（多由于终端客户的误用或硬件问题），
采用“先兵后礼”的策略，重在保证软件的健壮性；
契约式编程一般处理不应发生的异常（多由于程序员的错误），
采用“先礼后兵”的策略，重在保证软件的正确性。
二者互补共生，为软件的可靠性提供保障。

➢在契约式设计中，实现中包含设计——在语言层面上保证接口设计的规范性
在模型驱动架构中，设计中包含实现——模型语言UML可以作为高级的编程语言来使用。

➢把握抽象的级别比区分设计与实现更重要。
抽象程度越高，越接近设计，越远离实现，相应的语言也越高级

➢抽象本身并不能解决问题，但却是解决问题的必经之路。
通过抽象能简化和分解问题，使之更容易理解和控制，相应的解法也更具稳定性、普适性、重用性和可维护性。

数据抽象

数据类型与数据运算是程序语言的基本要素，

除了内建的类型与运算外，程序语言还提供了用户定义（user-defined）的扩展机制，以提高编程者的效率。
正如函数是一些基本运算的复合，自定义类型通常是一些基本类型的复合
不过单纯的复合类型并不是真正意义上的数据抽象

数据结构强调具体实现，多从实现者和维护者的角度来考虑；抽象数据类型强调抽象接口，多从设计者和使用者的角度来考虑。

比如栈、队列、表、集合、二叉树等作为数据结构，人们关心的是如何利用它们来有效地组织数据
而作为抽象数据类型，人们更关心的是类型的接口、逻辑行为及背后的数学模型

具体数据类型主要用于数据储存
除了getter和setter之外没有其他实质性的运算

设计模式：数据传输对象（Data Transfer Object或DTO），又称值对象（Value Object或VO）
这类对象不含任何业务逻辑，仅仅作为简单的数据容器，实质上也属于具体数据类型

队列的特征是先进先出（FIFO）
队列一般至少包括类似数据库的CRUD（增删改查）操作：
创建操作——建队；
删除操作——撤队；
修改操作——入队、出队；
查询操作——是否为空队、队列长度、队首。

队列类型QueueType，其核心是队列的成员集合。
无论是用数组来实现，还是用链表来实现，用户根本不需关心。
这便是队列的抽象所在——用户不应知道也不必知道它的具体实现
只能通过指定接口来进行‘暗箱操作’
这样经过数据抽象，队列的本质特征由API展现

参数抽象使得数据接口普适化，规范抽象使得数据接口契约化。

许多程序员都有一个通病：重实现，轻接口

在编写代码时表现为：不等接口设计好就技痒难忍，揎拳捋袖地开始大干

在阅读代码时表现为：看到看到API文档便恹恹欲睡，看到代码便两眼放光

Programming to an Interface,not an Implementation（针对接口而不是实现来编程）

摆脱数据类型的底层细节，通过高层接口来操纵对象，保证了客户代码的可读性和稳定性

开发者同样从中受益：接口与实现的分离，有利于开发时间的分离及开发人员的分离

开发时间的分离指的是：开发人员可以推迟在不同实现方式中作最后抉择

开发人员的分离指的是：代码的修改和维护不局限于原作者

整型的抽象之处在于
用户不须知道一个整数的底层究竟是如何表示的
以及整数运算是如何实现的
只须知道整型代表着数学概念上的整数，支持加减乘除等运算即可

许多人能将OOP中的封装、继承和多态说得头头是道，用得得心应手，便自认为精通OOP了
殊不知抽象,尤其是数据抽象
才是OOP的核心和起源，尽管它们并非OOP的专利
没有抽象作基础，封装、继承和多态尽皆无本之木

抽象——接口与实现相分离
数据——以数据为中心组织逻辑
类型——单纯而定义良好的概念

➢数据结构与抽象数据类型同为数据与运算的有机集合体，
常可看作同一事物的两个方面
前者强调具体实现，多从实现者和维护者的角度来考虑；
后者强调抽象接口，多从设计者和使用者的角度来考虑。

➢具体数据类型一般只是被动地作为数据储存或打包的工具，很少行为特征，与实现细节紧密相关。

➢数据抽象依赖于规范，包括所有的接口规范和数据类型的整体规范。

➢Programming to an Interface,not an Implementation

➢
分析阶段（OOA）以对象（而不是过程）为中心
设计阶段（OOD）以接口（而不是实现）为中心
实现阶段（OOP）以数据（而不是算法）为中心

➢数据抽象带给使用者的好处：
通过高层接口来操纵对象，保证了客户代码的可读性和稳定性

➢数据抽象带给开发者的好处：接口与实现的分离，有利于开发时间的分离及开发人员的分离

➢基本类型好比单质，抽象数据类型好比化合物，具体数据类型好比混合物

➢抽象（尤其数据抽象）是OOP的核心和起源，是封装、继承和多态的基础

封装隐藏

抽象是OOP三大基本特征的基础

广义的封装仅仅只是一种打包，即package或bundle
是密封的但可以是透明的。

封装就是把一些数据和方法装在一个封闭的盒子里
可能是黑盒子，也可能是白盒子

封装（encapsulation）与信息隐藏（information hiding）有区别

信息隐藏是一种原则，而封装是实现这种原则的一种方式

封装还有语法糖（syntactic sugar）效果

所谓语法糖，就是一些语法上的甜头
它不是核心语法，并没有提供任何额外的功能
只是用起来更简洁实用、更自然方便，看起来更酷、更炫而已

狭义的封装是在打包的基础上加上访问控制（access control），以实现信息隐藏

访问控制不仅是一种语法限制，也是一种语义规范——标有public的是接口，标有private的是实现

访问控制只是为了防止程序员的无意误用，不打算、也无法防止程序员的故意破坏

不能直接返回类的内部对象。用户可以在调用此方法后直接对生日进行操作，从而破坏了信息隐藏的规则
见Alarak/class_use.php

如果一个方法返回了一个可变（mutable）域对象（field object）的引用，无异于前门紧闭而后门洞开。

如何解决这个问题呢？这就需要用到前面提到的防御性编程，
更具体地说是防御性复制（defensive copying），即返回对象的一个复制品，以免授人以柄（handle）

普通的做法不代表是正确的。普通的程序员是不合格的，合格的程序员是不普通的。

可变和引用两个条件。基本类型都不是引用，作为传入参数或返回值时会自动被复制，因而是安全的；

实现细节，最好不要暴露给客户

建议，不妨将getSex换成isMale和isFemale两个接口。这也提醒诸位，不要陷入追求get和set对称美的僵框

set权利太大，可以改成addXXX和removeXXX

信息隐藏中的信息不仅仅是数据结构，还包括实现方式和策略。

封装和信息隐藏不仅属性私有化getter setter集中输入 输出 检查 打印这么简单

领会OOP的精髓绝非一年半载之功，以抽象与封装切入

总结
➢信息隐藏是一种原则，而封装是实现这种原则的一种方式

➢广义的封装是把一些数据和方法捆绑在一起，
从而引入了一种被称为类的模块，并使函数（方法）的调用更简洁、更符合认知模式

➢狭义的封装是在广义的封装的基础上加上访问控制，以实现信息隐藏

➢（狭义）封装从语法上强化了抽象
即用户不仅可以从高层接口来对待一类对象
而且不用关心也无权访问底层实现

➢访问控制不仅是一种语法限制
也是一种语义规范
明确地将接口与实现分离开来

➢访问控制不是牢不可破的
C++可以通过指针、Java和C#可以通过反射来绕过访问限制

➢信息隐藏的关键是掩盖实现细节，包括内部数据结构和算法逻辑
但知易行难，常见的错误有：
将可变的内部对象引用作为返回值；
将可变的对象引用直接赋值给内部对象；
没有进行必要的深拷贝；
接口方法的参数或返回值类型不够抽象；
在方法命名上透露实现策略

➢值对象重在值而非同一性，引用对象重在同一性而非值。
如果值对象是可变的，
往往须要利用值拷贝来防止因同一性而导致的意外同步变化。

➢从宏观上看，知识是延伸相通、大道合一的；
从微观上看，知识又是至精至微、各具奥妙的。

➢抽象与封装是OOP的关键所在。

设计阶段可细分为：偏向宏观战略的架构设计（architectural design）和偏向微观战术的详细设计（detailed design）

数据抽象的规范性大大降低了代码的修改和维护的难度。

反射机制多用于单元测试、代码分析、框架设计等，在常规应用中，除实例化编译期未知类外一般不宜使用。

迟拷贝是浅拷贝与深拷贝的折衷方案：
起初浅拷贝，必要时（如被修改）转为深拷贝。
常见的形式是写时拷贝（copy-on-write，简称CoW）。
php用了copy-on-write,当分配给变量一个值时，php会在变量发生修改时时，才会创建copy
