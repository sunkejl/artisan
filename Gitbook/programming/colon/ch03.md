Generic Programming，简称GP
泛型编程

其基本思想是：将算法与其作用的数据结构分离，并将后者尽可能泛化，最大限度地实现算法重用。
这种泛化是基于模板（template）的参数多态（parametric polymorphism），
相比OOP基于继承（inheritance）的子类型多态（subtyping polymorphism），不仅普适性更强，而且效率也更高。

这不能不说是一种异数——我们知道，普适性往往是以效率为代价的。如果一定要找出代价的话，
那就是其用法稍微复杂一些，可读性稍微差一些。GP最著名的代表是C++中的STL（StandardTemplateLibrary），
其后亦为Java、C#、D等语言所吸纳
此外，一些函数式语言如Ocaml、StandardML、Haskell等也支持GP。

STL有3要素：算法（algorithm）、容器（container）和迭代器（iterator）
算法是一系列切实有效的步骤；
容器是数据的集合，可理解为抽象的数组；
迭代器是算法与容器之间的接口，可理解为抽象的指针或游标。

泛型编程是算法导向（Algorithm-Oriented）的，即以算法为起点和中心点，
逐渐将其所涉及的概念（如数据结构、类）内涵模糊化、外延扩大化，将其所涉及的运算（函数、方法、接口）抽象化、一般化，
从而扩展算法的适用范围。这非常类似数学思维——当数学家证明完一个定理后，总会试图在保持核心思想的前提下，
尽可能地放宽题设，增强结论，从而推广定理。外行人常以为数学定理最重要，其实数学思想才是数学的精髓。

泛型编程能打破静态类型语言的数据类型之间的壁垒，在不牺牲效率并确保类型安全的情况下，最大限度地提高算法的普适性。

STL有3要素：算法、容器和和迭代器。算法是一系列可行的步骤；
容器是数据的集合，是抽象化的数组；
迭代器是算法与容器之间的接口，是抽象化的指针。
算法串联数据，数据实化算法。

泛型编程不仅能泛化算法中涉及的概念（数据类型），还能泛化行为（函数、方法、运算）。

泛型编程是算法导向的，以算法为中心，逐渐将其所涉及的概念内涵模糊化、外延扩大化，并将其所涉及的运算抽象化、一般化，从而提高算法的可重用性。



元编程（Meta programming），简称MP。

此处的前缀‘meta-’常译作‘元’，其实就是‘超级’、‘行而上’的意思。
比如，元数据（Meta data）是关于数据的数据，
元对象（Meta object）是关于对象的对象，
依此类推，元编程自然是关于程序的程序，或者说是编写、操纵程序的程序。

编译器本身就是元编程的典型范例——把高级语言转化为汇编语言或机器语言的程序，就是能写程序的程序

更加激进的语言导向式编程（Language-OrientedProgramming，简称LOP）。

这种编程范式的思路是：在建立一套DSL体系之后，直接用它们来编写软件，尽量不用通用语言。

如果说OOP的关键在于构造对象的概念，
那么LOP的关键在于构造语言的语法。
有人认为LOP是继OOP之后的下一个重要的编程范式，

元编程的例子比比皆是：
许多IDE如VisualStudio、Delphi、Eclipse等均能通过向导、拖放控件等方式自动生成源码；
UML建模工具将类图转换为代码；
Servlet引擎将JSP转换为Java代码；
包括Spring、Hibernate、XDoclet在内的许多框架和工具都能从配置文件、annotation/attribute等中产生代码。

自动生成源代码的编程也属于另一种编程范式——产生式编程（Generative Programming）的范畴。
区别在于后者更看重代码的生成，而元编程看重的是生成代码的可执行性。
另外，除了在编译期间生成源代码的静态元编程，还有能在运行期间修改程序的动态元编程。
从低级的汇编语言到一些高级的动态语言如Perl、Python、Ruby、JavaScript、Lisp、Prolog等均支持此类功能。
比如，许多脚本语言都提供eval函数，可以在运行时将字符串作为表达式来运算

在传统的编程中，运算是动态的，但程序本身是静态的；
在元编程中，二者都是动态的。
元程序将程序作为数据来对待，能自我发现、自我赋权和自我升级，有着其他程序所不具备的自觉性、自适应性和智能性，
可以说是一种最高级的程序。它要求编程者超越常规的编程思维，在一种崭新的高度上理解编程。

➢元编程是编写、操纵程序的程序。在传统的编程中，运算是动态的，但程序本身是静态的；在元编程中，二者都是动态的。
➢元编程能减少手工编程，突破原语言的语法限制，提升语言的抽象级别与灵活性，从而提高程序员的生产效率。
➢元编程有诸多应用：许多开发工具、框架引擎之类的基础软件都有自动生成源代码的功能；
创造DSL以便更高效地处理专门领域的业务；自动生成重复代码；
动态改变程序的语句、函数，类，等等。
➢IDE下自动生成的代码通常局限性大且可读性差，小操作可能造成的源码上的大差异，削弱了版本控制的意义。
用自编的无需人机交互的元程序来生成代码，只须将元程序的数据来源版本化，简明而直观。
同时由于元程序可以随时修改，因此局限性小，更加灵活。
➢语言导向式编程（LOP）通过创建一套专用语言DSL来编写程序。
相比通用语言，DSL更简单、更抽象、更专业、更接近自然语言和声明式语言、开发效率更高，同时有助于专业程序员与业务分析员之间的合作。
➢语言导向式编程一般通过元编程将专用语言转化为通用语言。➢产生式编程与静态元编程都能自动生成源代码。产生式编程强调代码的生成，元编程强调生成代码的可执行性。此外，动态元编程并不生成源代码，但能在运行期间修改程序。➢元程序将程序作为数据来对待，有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的程序。


###代码优化

SoC就是Separation of Concerns，即关注点分离；
DRY是Don'tRepeatYourself，即尽量减少重复代码。


不良代码通常有两种病征：
一是结构混乱，或聚至纠缠打结、或散至七零八落；
二是代码重复，臃肿不堪。

有效的方法是抽象与分解：
从问题中抽象出一些关注点，再以此为基础进行分解。
分解后的子问题主题鲜明且独立完备，既不会牵一发而动全身，也不会四分五裂、支离破碎。
同时具有相同特征的部分可以像代数中的公因子一样提取出来，提高了重用性，减少了重复性。

抽象是前提，分解是方式，模块化是结果。

###抽象与分解的原则
单一化，正交化。
每个模块职责明确专一，模块之间相互独立，即高内聚低耦合（high cohesion&low coupling）。
此原则相当普适，是分析复杂事物的一种基本方法，
在数学和物理中应用得尤为广泛，如质因式分解、正交分解、谱分解，等等。
在数学中互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响，

切面范式——AOP

英文好的技术不好，技术好的英文不好，两者都好的不屑去翻译，导致市面上的译书虽汗牛充栋，然佳作寥寥。
这里奉劝各位，如果真想成为优秀的程序员，一定要尽可能地读原文的书籍、文章和文档。
事实上，凡是科学和艺术方面的专业人员，要想专业水平上一层台阶，都应读该专业权威经典原文。
要知道，语言之间的天堑原本难以弥合，译者的专业水准、语言功底和严谨程度更是参差不齐。
纵使万事俱备，一年半载后的译书便如隔夜的饭菜，虽刚出炉，已然不新鲜了。

对程序员来说，英语也是一门计算机语言，而且是必修的语言。


➢SoC是Separation of concerns的缩写，指应将关注点分离；
DRY是Don'tRepeatYourself的缩写，指应尽量减少重复代码。

➢抽象与分解是治愈代码紊乱、松散、重复的良方。

➢抽象与分解的原则是单一化和正交化，以保障软件系统符合“高内聚、低耦合”的要求。

➢横切关注点指与程序的纵向主流执行方向横向正交的关注焦点。

➢接入点是附加行为——建议（advice）的执行点，切入点（pointcut）是指定的接入点（joinpoint）集合，这些接入点共享一段插入代码。
切入点与建议组成了切面（aspect），是模块化的横切关注点。

➢编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。
编织分静态编织和动态编织两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。

➢AOP的实施分3步：切面分解、切面实现和切面合成。

➢OOP只能沿继承树的纵向方向重用，AOP可以沿横向方向重用。

➢语言之间的天然差别、译者的专业水准、语言功底和严谨程度及时间上的滞后决定了阅读原文书籍和资料的必要性。


###事件驱动

采用警觉式者主动去轮询（polling），行为取决于自身的观察判断，是流程驱动的， 符合常规的流程驱动式编程（Flow-DrivenProgramming）的模式。

采用托付式者被动等通知（notification），行为取决于外来的突发事件，是事件驱动的，符合事件驱动式编程（Event-DrivenProgramming，简称EDP）的模式。

事件:通俗地说，它是已经发生的某种令人关注的事情。

在软件中，它一般表现为一个程序的某些信息状态上的变化。

基于事件驱动的系统一般提供两类的内建事件（built-in event）：
一类是底层事件（low-level event）或称原生事件（native event），在用户图形界面（GUI）系统中这类事件直接由鼠标、键盘等硬件设备触发；
一类是语义事件（semantic event），一般代表用户的行为逻辑，是若干底层事件的组合。比如鼠标拖放（drag-and-drop）多表示移动被拖放的对象，
由鼠标按下、鼠标移动和鼠标释放三个底层事件组成。

用户自定义事件（user-defined event）。它们可以是在原有的内建事件的基础上进行的包装，也可以是纯粹的虚拟事件（virtual event）。
除此之外，编程者不但能定义事件，还能产生事件。虽然大部分事件是由外界激发的自然事件（natural event），
但有时程序员需要主动激发一些事件，比如模拟用户鼠标点击或键盘输入等，这类事件被称为合成事件（synthetic event）

消息是Windows内部最基本的通信方式，事件需要通过消息来传递，是消息的主要来源。
每当用户触发一个事件，如移动鼠标或敲击键盘，系统都会将其转化为消息并放入相应程序的消息队列（message queue）中

回调函数（callback）
写了一个应用层的函数，却不直接调用它，而是通过库函数间接调用。

函数指针是C和C++用来实现callback的一种方式。
此外，抽象类（abstract class）、接口（interface）、C++中的泛型函子（generic functor）和C#中的委托（delegate）都可实现callback。

我们把系统划分为两层：
低层的函数库和高层的应用程序。
同样作为主函数的辅助函数，
普通函数直接被主函数调用，
回调函数却是通过库函数间接被主函数调用的。
通过调用系统函数调用自己写的函数

一般都是高层代码调用低层代码，callback反其道而行之，

一方面，在软件模块分层中，低层模块为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；
另一方面，通常被调者（callee）为调用者（caller）提供服务，调用者依赖被调者。
两相结合，决定了低层模块多为被调者，高层模块多为调用者。
但这种惯例并不总是合适的——
低层模块为了追求更强的普适性和可扩展性，有时也有调用高层模块的需求，于是便邀callback前来相助。

将侦查事件与响应事件两项任务进行了正交分解，降低了软件的耦合度和复杂度。

在字符串组排序中，callback在作为参数传入低层的函数后，很快就在该函数体中被调用；
在窗口程序中，callback则先被储存起来，至于何时被调用完全是未定之数。
用一句话概括：前者属同步（synchronous）回调，后者属异步（asynchronous）回调。
它们都使调用者不再依赖被调者，将二者从代码上解耦，异步调用更将二者从时间上解耦。

Don't call us,we'll call you.

相当于一个callback，
留下你的电话 就是注册callback，
我们会打给你的 就是异步调用callback。

控制反转（Inversion of Control，简称IoC）

一般library中用到callback只是局部的控制反转，
而framework将IoC机制用到全局。
程序员牺牲了对应用程序流程的主导权，换来的是更简洁的代码和更高的生产效率。
如果将编程譬比命题作文，
不用framework的程序是一张可以自由写作的白纸，library是作文素材库；
采用framework的程序是一篇成型的作文，作者只须填写空白的词语和段落即可。

控制反转不仅增强了framework在代码和设计上的重用性，还极大地提高了framework的可扩展性。
这是因为framework的内部运转机制虽是封闭的，但也开放了不少与外部相连的扩展接口点，类似插件（plugin）体系

依赖反转原则（Dependency-InversionPrinciple，简称DIP）
高层模块不应依赖低层模块，它们都应依赖抽象；
抽象不应依赖细节，细节应依赖抽象。

经常相提并论的还有
依赖注射（DependencyInjection，简称DI）
动态地为一个软件组件提供外部依赖。由于时间关系，它们之间的区别容后再叙。
有一点可以看出，它们的主题是控制与依赖，目的是解耦，方法是反转，
而实现这一切的关键是抽象接口。

回调函数的提法较为古老，多出现于过程式编程，
抽象接口是更现代、更OO的说法。
另外，从字面上看，
回调强调的是行为方式——低层反调高层，
而抽象接口强调的是实现方式——正是由于接口具有抽象性，低层才能在调用它时无须虑及高层的具体细节，从而实现控制反转。

与事件直接相关的有3步：
实现事件处理器（event handler）或事件监听器（event listener）；
注册事件处理器；实现事件循环（event loop）。
具体说来，事件处理器负责处理事件，经注册方能在事发时收到通知；
事件循环负责侦查事件、预处理事件、管理事件队列和分派事件等，无事时默默等待，有事时立即响应
在整个事件机制中，主循环好比心脏，事件处理器好比大脑，是最重要的两类模块。

自行设计整个事件系统，需要决定：
采用事件驱动式是否合适？如果合适，如何设计事件机制？
其中，包括事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带（event cascade）等一系列问题。

软件的可伸缩性（scalability）一般指从容应对工作量增长的能力，
常与性能（performance）等指标一并被考量。
而控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，提高软件的可重用性、柔韧性和可扩展性，
但对可伸缩性并无太大帮助。

控制反转导致了事件驱动式编程的被动性（passivity）。
此外，事件驱动式还具有异步性（asynchrony）的特征，
这是由事件的不可预测性与随机性决定的。
如果一个应用中存在一些该类特质的因素，比如频繁出现堵塞呼叫（blocking call），不妨考虑将其包装为事件。

在程序中一些函数须要等待某些数据而不能立即返回，从而堵塞整个进程。

可以让堵塞呼叫暂时脱离主进程，事成之后再利用事件机制申请重返原进程。
相比第1种同步流程式的方案，这种异步事件式将连续的进程中独立且耗时的部分抽取出来，
从而减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。

事件驱动式模型。事件处理器事先在关注的事件源上注册，后者不定期地发表事件对象，
经过事件管理器的转化（translate）、合并（coalesce）、排队（enqueue）、分派（dispatch）等集中处理后，
事件处理器接收到事件并对其进行相应处理。请注意事件处理器随时可以注册或注销事件源，意味着二者之间的关系是动态建立和解除的。
通过事件机制，事件源与事件处理器之间建立了松耦合的多对多关系：
一个事件源可以有多个处理器，处理器，一个处理器可以监听多个事件源。再换个角度，把事件处理器视为服务方

事件源视为客户方，便是一个client-server模式。
每个服务方与其客户方之间的会话（session）是异步的，即在处理完一个客户的请求后不必等待下一请求，
随时可切换（switch）到对其他客户的服务。
更有甚者，事件处理器也能产生事件，实现处理器接口的事件源也能处理事件，它们可以角色换位，于是又演化为peer-to-peer模式。


发行/订阅模式（publish-subscribe pattern）正是观察者模式（observer pattern）的别名，
一方面可看作简化或退化的事件驱动式，
另一方面可看作事件驱动式的核心思想。
该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口。
这样更加简明易用，但威力有所削弱，缺少事件管理、事件连带等机制。
著名的MVC（Model-View-Controller）架构正是它在架构设计上的一个应用

事件管理器包括
事件转化
事件合并
事件排队
事件分配

➢事件是程序中令人关注的信息状态上的变化。在基于事件驱动的系统中，事件包括内建事件与用户自定义事件，其中内建事件又分为底层事件和语义事件。
此外，事件还有自然事件与合成事件之分。

➢Callback指能作为参数传递的函数或代码，它允许低层模块调用高层模块，使调用者与被调者从代码上解耦。
异步callback在传入后并不立即被调用，使调用者与被调者从时间上解耦。

➢控制反转一般通过callback来实现，其目的是降低模块之间的依赖性，从而降低模块的耦合度和复杂度。

➢在框架设计中，控制反转增强了软件的可重用性、柔韧性和可扩展性，减少了用户的负担，简化了用户的代码。

➢控制反转、依赖反转原则和依赖注射是近义词，它们的主题是控制与依赖，目的是解耦，方法是反转，
而实现这一切的关键是抽象接口（包括函数指针、抽象类、接口、C++中的泛型函子和C#中的委托）。

➢事件驱动式编程的3个步骤：实现事件处理器；注册事件处理器；实现事件循环。

➢异步过程在主程序中以非堵塞的机制运行，即主程序不必等待该过程的返回就能继续下一步。
异步机制能减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。

➢独立是异步的前提，耗时是异步的理由。

➢事件驱动式最重要的两个特征是被动性和异步性。被动性来自控制反转，异步性来自会话切换。

➢观察者模式又名发行/订阅模式，既是事件驱动式的简化，也是事件驱动式的核心思想。MVC架构是观察者模式在架构设计上的一个应用。

虽然调试与日志和测试不是一码事，但合理的日志和单元测试能大量减少调试工作。

耦合（coupling）用来衡量模块之间的依赖程度，
内聚（cohesion）用来衡量模块内在的关联强度。
它们常用来作为软件质量的评判标准，耦合度宜低，内聚度宜高。

Windows先把所有的硬件事件存入系统消息队列（system message queue），然后再放入应用程序消息队列（application message queue）。

有人将发行-订阅模式视为事件驱动设计的同义词，这是有道理的：
在实际生活中，处于出版商与订阅者之间的邮局可作为事件管理器。

MVC也可作为一种设计模式，同样是观察者模式的应用。
