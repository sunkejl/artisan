设计原则

间接原则

Anyproblemincomputersciencecanbesolvedwithanotherlayerofindirection

任何计算机的问题可以通过增加一个间接层来解决

不错。在计算机领域，类似引用的例子不胜枚举。像文件系统中的路径（path）、HTTP中的URI（UniformResourceIdentifier）、数据库中的外键（foreignkey）、程序中的变量等都具有间接指代作用。”

变量名函数名都可以理解为间接层

在命令式编程中，变量是抽象化的内存，是不可或缺的机制。
即使在非必需的情况下，选择合适的变量仍然是值得推荐的。
比方说，初学者的代码中经常会出现一些令人费解的常数值，俗称幻数（magicnumber或magicconstant）

变量比幻数更能凸显编程者的意图，增强了代码的可读性。当幻数出现在多处而又需要修改时，用变量代替后则只须改动一处，增强了代码的可维护性。”

函数与变量一样，是过程式编程中最基本的要素之一，二者的机理也同出一辙
——都提供了一种抽象机制和间接手段，
分别把代码和表达式抽象化和间接化。
抽象的意义在于：一方面掩盖了具体的细节，提高了代码的简洁度；
另一方面赋予了明确的语义，提高了代码的清晰度。
而间接的意义在于：一方面建立了名与实的映射，提高了代码的一致性和可维护性；
另一方面实现了名与实的分离，提高了代码的灵活性和可扩展性。

间接层与抽象层可以看作同一事物的两个方面：
一个适当的中间层[3]，在形式上表现为间接层，在实质上体现为抽象层。
在软件设计中，体现这种统一性的范例俯拾皆是。
比如出于安全原因，应用程序一般无权直接与硬件打交道，
只能通过操作系统最核心的部分——内核（kernel）间接地访问底层资源。
作为硬件与应用程序的中介，内核提供了抽象的API接口，
使得应用程序能借助系统调用（systemcall）向其请求服务。

多层架构也是应用间接层

典范，最著名的包括网络协议的OSI7层模型（OSISevenLayerModel）、
TCP/IP4层模型和网络应用系统的3层或N层架构（n-tierarchitecture）。
这类架构的特点是：每一层都有特定的职能，
一面向上层提供服务，一面向下层寻求服务；
下层不依赖于上层，上层只依赖于相邻的下层[4]。
特别地，如果某一层是一个相对独立的子系统，
那么它在概念上等同于一个具有特殊使命的虚拟机。


MVC代表3个模块：模型（Model）、视图（View）和控制器（Controller），
而最常见的3层架构分别是：
表现层（presentationtier/layer）、业务层（businesstier/layer）和数据层（datatier/layer）。
初看起来，
二者似乎是一一对应的关系：
模型与数据层都关乎数据访问、
视图与表现层都关乎用户界面、
控制器与业务层都关乎逻辑控制，
但它们之间的相互关系却有很大的差异。

企业级应用

常以多用户、大数据量、分布式、高并发、高集成、跨平台为特征，
对软件质量的要求相应也更高。
人们不仅需要保证包括
可扩展性（extensibility）、可维护性（maintainability）、可重用性（reusability）等在内的设计质量，
更对包括
安全性（security）、可靠性（reliability）、可伸缩性（scalability）、
性能（performance）、可获性（availability）、互用性（interoperability）等在内的运行质量有着严苛的要求。
3层架构中的‘层’，如果指的是layer，则是对系统逻辑上的划分，有助于提高软件的设计质量；
如果指的是tier，则是对系统进一步的物理上的划分，即不同的层运行于不同的服务器上，
有助于提供软件的运行质量。
3层架构与MVC架构并不是对立的，后者常常嵌入前者的表现层。我们看一个基于JavaEE的应用架构。


审视OOP。首先考察封装，它把相关的数据和运算包装后再设置访问控制。外界无法直接操作被隐藏的数据，只能通过公开接口间接地读取或改写这些数据。”


类的公开接口集即API担任了间接层的角色，
成为外界与内部实现之间的联系桥梁。
在使用者看来，API是访问服务类的唯一中介；
在维护者看来，服务类可以自由地更换具体实现而不担心影响客户类。
进一步地，人们还能在客户类与服务类之间插入新的间接层——接口（interface）。
该接口在编译期为实现类所继承，在运行期通过多态机制绑定实现类。


OOP的3大基本特征分别带给对象3种身份，每种身份都是规范抽象的结果。其实分离原则也好，间接原则也罢，背后的核心仍是抽象原则。
封装带来的接口与实现的分离，使得类的API成为间接层，从而完成数据抽象；
继承和多态带来的接口与实现的分离，使得类的超类型成为间接层，从而将数据抽象升级为多态抽象。
再联系到前面探讨的间接层与抽象层之间、规范与抽象之间的关系，
我们可以得出这样一个结论：间接、分离、抽象、规范，这几个在日常语义中似乎没有必然联系的概念，
却在计算机领域中奇妙地达成了契合。


总结➢间接原则：任何计算机问题均可通过增加一个间接层来解决。➢函数与变量分别把代码和表达式抽象化和间接化。抽象化提高了代码的简洁度和清晰度，间接化提高了代码的一致性、可维护性、灵活性和可扩展性。

➢一个适当的中间层，在形式上表现为间接层，在实质上体现为抽象层。➢3层架构中的3个层级是线性关系，而MVC架构中的是三角关系。➢3层架构通常是最高层的架构设计，多出现在企业级应用中。MVC作为架构或设计模式主要用于交互式系统，常常嵌入3层架构的表现层中。➢小至引用、变量、函数等基本编程元素，大至操作系统的内核、虚拟机、多层架构、MVC架构等，都是间接原则的应用实例。➢类的API充当了外界与内部实现之间的中介，接口是客户类与服务类之间的间接层。➢在软件设计中，间接、分离、抽象、规范是相生相依、互为因果的。➢引入具有间接功能的抽象模块，有助于构建“低耦合、高内聚”的系统。但过多的间接层也会给系统带来一定的复杂性，并有时空性能的损耗。


依赖原则

间接原则有一个直接的推论，那便是依赖反转原则（DependencyInversionPrinciple），简称DIP。


接口一方面作为一种抽象类型，描述了一类对象所应遵循的行为规范；另一方面作为间接层，把两个耦合的具体类进行了分离。”


从代码实现的角度看，高层模块对低层模块的依赖是非常自然的。
而且，高层模块与低层模块往往是决策（policy）与机制（mechanism）之间的关系，
高层决策以底层机制为基础，逻辑上似乎也是合理的。
然而从软件设计上的角度看，这种依赖性却是非常不合理的。
为什么呢？大家知道，依赖通常是具有传递性的（transitive），即A依赖B，B依赖C，那么A将依赖C。
C是最底层
这意味着任何依赖高层模块的客户代码最终将依赖低层模块，
一旦低层模块发生变化，很可能会波及高层的客户代码。
退一步说，即便低层模块不变，高层模块往往也会在不同的环境下选取不同的低层模块。
如果把这种因地制宜的策略硬编码（hardcode）到高层模块中，它的可维护性和可扩展性将受到严重限制。
相应地，高层模块的可重用性和可移植性（portability）也会大大降低。
为了解决高层模块对低层模块的依赖问题，人们提出了依赖反转原则。




DIP在解除了高层模块与低层模块的依赖关系的同时，又在它们与某个抽象模块之间建立了新的依赖关系。
虽然依赖仍然存在，但重构后的依赖体系比旧的更加优越，
这是因为：抽象模块脱离了具体的细节，更稳定更持久，
从而整体的系统结构更具有弹性、更经得起需求和环境的变化。

DIP倡导依赖抽象，而抽象在此处最大的目的是稳定，
因此依赖反转原则可重述为稳定依赖原则（StableDependenciesPrinciple，简称SDP）：
模块应朝着稳定的方向依赖。
至于为什么说是依赖‘反转’，我们以数据库应用为例。
由于数据库系统的开发商各自为政，提供的API不仅复杂晦涩，而且彼此之间差异很大。
如果应用程序直接通过数据库系统的API访问数据库，代码将既繁杂又难维护，因而有必要利用间接原则，
在应用程序和数据库API之间铺一层中介模块。为保证该模块的通用性和可重用性，还须按照DIP的要求，
即新增的高层模块不能依赖低层模块，二者应共同依赖一套稳定的标准规范。

规范的合理度和遵循度很大程度决定了软件的质量。
DIP与‘针对接口编程’原则一脉相承，提倡编程应依赖规范而非实现、
依赖抽象而非细节。它还顺便印证了我们从前的观点——具体类不宜被继承，因为继承是一种深度依赖，而具体类不足够抽象。”



合成比继承的一个优势是它是隐性的、动态的，
这使得在合成类与被合成类之间有了插入抽象层的可能。
当抽象层利用了多态机制时，
这种合成也被称为多态合成（polymorphiccomposition）。结合此前关于继承用法的忠告，
我们便有了合成重用原则（CompositeReusePrinciple，简称CRP）：
多态合成优于（实现）继承（favorpolymorphiccompositionoverinheritance）。
举例来说，窗口（window）通常是一个矩形。假设矩形类是一个现成的具体类，
我们当然不希望窗口类继承它，因为二者不是is-a的关系，而是has-a的关系。



引入接口后依赖于抽象运用了依赖反转
接口相当于中间件底层和高层共同依赖一套稳定的标准规范。

依赖注射（DependencyInjection）DI

依赖反转和依赖注入侧重点不同。
DI依赖注入强调依赖的来源——完全由外部提供，该依赖自然最好是抽象的，但并非首要要求；
DIP依赖反转则强调依赖的抽象性。其次，它们的应用范围不同。
DI是更加具体的策略，一般用于类级别的模块，故为一种设计模式；
DIP还可用于类库、组件、架构层等大级别的模块，故为一种设计原则。

DI依赖注入的要点：少一份责任则多一份专注，内聚度随之增加；少一份权力则多一份自由[7]，耦合度随之降低。


依赖没有消失只是转移

采用DI模式后，通常会安排专门的模块——不妨称为供应者（provider）或装配器（assembler）——来管理外来依赖的对象，
这是一种良好的职责分工，符合关注点分离（SoC）原理。
它们好比一个装配车间，负责把须要依赖注射的模块当作零部件那样组装成产品。
程序员可自行构造这类模块，也可以利用DI容器（DIcontainer）


术语——组件（component）。我们定义组件为一组具有特定功能规范的可重用的软件单元，
是不依赖于应用程序的模块。
它的涵盖面很广，可以大到子系统、网络服务（webservice）、框架、类库，也可以小到若干个相互协作的类乃至单个类和函数。
组件是一个抽象层，
也可看作一个广义的抽象数据类型（ADT），因为它们都是通过规范接口为客户提供一系列相关的服务。
再说回控制反转（IoC），它是一个较为普遍的原则，
广泛地应用于框架（framework）设计中。它打破了常规的流程控制模式，
把控制权从用户的应用代码转给了底层的某个组件。控制反转并无严格的定义，
但可抽象为一种管理组件依赖的机制，以保证组件总能在合适的时候获得合适的依赖。
显然，依赖注射是控制反转的一种实现方式[9]，广泛地为轻量级的Spring容器所采用。
此外，依赖查找（DependencyLookup）[10]是另一种实现方式，广泛地为重量级的EJB2.0容器所采用。
总的说来，依赖反转为实现控制反转提供了一个准则——依赖抽象，
而依赖注射则是遵循该准则的一种具体技巧。
这3个原则都在‘依赖’上做文章，不妨统称为依赖原则。

回调，乃是往回调，既不是往上调，也不是往下调。
这说明先有一个主体或出发点，方谈得上一个‘回’字。
在回调函数中提到的主体是底层函数库，
在依赖反转中提到的主体是高层模块。
尽管它们所处的相对位置不同，但都属于我们所定义的可重用的组件，
它们的共同点，或者说控制反转与依赖反转的共同点是：
通过引入抽象来摆脱对外界不必要的依赖性、争取对外界必要的控制权。


依赖原则既可适用于框架或架构设计，也可作为一种设计模式。不仅如此，它的思想还全方位地渗透于OOP之中。
早先我们有一个比喻：过程式程序是君主制的，对象式程序是民主制的。
君主制与民主制的一大差别是：前者是高度集权的，后者是合理分权的，
因此，从过程式演化为对象式的过程[15]是一个权力去中心化的过程。
而权力在程序中主要体现为流程控制，故权力的转移也是控制的转移，
当这种转移以抽象接口——主要指interface和abstractclass——为媒介时，便成了控制反转。

抽象与规范、间接与分离、依赖与控制，此外还有一对——接口与服务。
每一对中的靠前者更具代表性，故而我们把它们分别称为抽象原则、间接原则、依赖原则和接口原则。
所谓接口原则，是我们多次提到的‘针对接口编程’原则的简称。
此处的接口不限于OOP中以interface和abstractclass为代表的抽象类型，也可以指任何一个组件为外界提供的API[16]。
我们已经揭示了前3大原则之间的联系，再看接口原则与它们之间的联系。
由于服务可看作接口的同义语，只是接口更偏重语法、服务更偏重语义，故以下仅以接口为代表贯穿6个关键词：
接口是一种抽象，因为它掩盖了实现细节；
接口是一种规范，因为它定义了服务契约；
接口是一种间接，同时还是实现间接层的关键手段；
接口可以产生分离，规范与实现的分离、职责的分离、关注点的分离；
接口作为解耦点，可以消除非本质的依赖；
接口作为反向控制点，可以抽象地调用外部依赖而无须虑及它们的具体实现。
一言以蔽之，抽象与规范是根本，间接与分离是手段，依赖与控制是关键，接口与服务是核心。

抽象接口往日主线
间接依赖新的趋势

总结➢DIP（依赖反转原则）可作为间接原则的一个推论，即在高层模块与低层模块之间引入一个抽象层。该抽象层实际隶属于高层模块，因此把高层依赖于低层的关系“反转”为低层依赖于高层的关系。➢DIP并不能真正消除依赖，但改善了系统的依赖体系，使之更能经受需求和环境的变化。➢DIP倡导依赖抽象层，是因为抽象层更稳定，因此依赖反转原则可重述为稳定依赖原则：模块应朝着稳定的方向依赖。➢DIP与“针对接口编程”原则均提倡：编程应依赖规范而非实现、依赖抽象而非细节。



➢多态合成是在合成类与被合成类之间利用多态机制插入抽象层（接口），它优于实现继承（即合成重用原则CRP）。➢DI（依赖注射）强调依赖是来源于外部的，DIP则强调依赖是抽象的。➢DI一般用于类级别的模块，故为一种设计模式；DIP还可用于类库、组件、架构层等大级别的模块，故为一种设计原则。➢DI模式的思想是：组件放弃管理依赖的生命周期以增加内聚度，并让依赖抽象化以减少耦合度。➢控制反转可抽象为一种管理组件依赖的机制，以保证组件总能在合适的时候获得合适的依赖。它的两种主要实现方式是依赖注射和依赖查找。➢控制反转的思想：引入抽象规范以解除组件对客户的直接依赖，使组件的服务更广泛；借助抽象接口来完成组件对客户的反向控制，使组件的服务更深入。➢控制反转与依赖反转的共同点是：通过引入抽象来摆脱对外界不必要的依赖性，争取对外界必要的控制权；不同点是：前者更侧重保证组件的可重用性，后者更



侧重保证组件的可维护性。➢从过程式演化为对象式的过程是一个权力（或控制）去中心化的过程，当这种权力（或控制）的转移以抽象接口为媒介时，便成了控制反转。➢抽象与规范是根本，间接与分离是手段，依赖与控制是关键，接口与服务是核心。




内聚原则


低耦合和高内聚原则不仅仅适合于OOP，它们是软件模块设计的通用原则。
这里的模块包括函数、类、包、组件、子系统等。
事实上，该原则最初出现在结构化设计（structureddesign）中，后被引入对象式设计。
耦合与内聚是衡量软件设计质量的两个重要尺度，
更具体地说，是检验模块设计是否合理的主要标准。
其中，耦合（coupling）反映模块之间的关联程度，内聚（cohesion）反映模块内部的关联强度。
‘低耦合、高内聚’原则可以简单地用4个字来概括：内亲外疏——对内亲密无间，对外形同陌路。
虽然这种作法在现实世界中实在不足为训，但在软件世界中却该奉为圭臬。”


为此，每个模块的职责应当单一而明确，模块之间的关系应当简单而清晰，即遵循低耦高聚的原则，以保证软件的可理解性（understandability）、可维护性（maintainability）、可重用性（reusability）和可测试性（testability）。”


耦合当然不可完全被消除，因为模块之间是通过耦合来相互协作的。
我们要避免的是非本质的、不恰当的或过于紧致的耦合。
比如，当一个模块有权对另一个模块的内部数据进行直接访问或修改时，二者的关系就属于内容耦合（contentcoupling），
应通过信息隐藏来防止。

再比如，两个模块因共享某个全局变量而发生了公共耦合（commoncoupling），这种关系也不值得提倡，
可以通过引入适当的接口来代替。
我们刚刚谈论的抽象原则、接口原则、间接原则和依赖原则，
都从不同角度为模块的松耦合化提供了指导和方法。
如果发现两个模块的依赖关系过于紧密，以致降低它们耦合的做法是徒劳无益的，
那么很可能二者有着本质的关联，不妨将它们合为一体，
原先高耦合的缺点立马变成了高内聚的优点。


先从软件设计中的一个基本原则谈起。
在编程中，一个良好的习惯是尽量把密切相关的软件元素放在一起，
这便是局部化原则（localityprinciple）[17]：让代码的物理紧密度与逻辑紧密度保持一致。

局部化可以增强代码的可读性和一致性，结合语法机制还能减少代码改动所产生的影响范围。
全局变量之所以不被提倡，关键就是它的辐射范围过广而难以控制，
可将其限制为静态全局变量[18]（staticglobalvariable）或局部变量，
或者利用各种语法容器使其局部化，比如命名空间（namespace）、包（package）、函数、类、块等。
这同时也印证了各种内部类（innerclass）或嵌入类（nestedclass）存在的价值。
类似地，能作为实例成员（instancevariable）的就不要作为类成员（classvariable），
能作为局部成员的就不要作为实例成员。



局部化不仅体现在源代码上，还体现在配置文件（configurationfile）上。
每个配置文件都聚集了一些相关的系统设置，可以方便地统一管理和修改，克服了硬编码的缺陷。


annotation注释代替配置文件


配置文件的一个为人诟病之处是：配置信息与其所关联的对象分属不同的文件，
造成理解上的障碍和维护上的不便。从这方面说，它违背了局部化原则。
属性导向式编程（Attribute-OrientedProgramming或@OP）可以解决这个问题：
无论是Java中的annotation，还是C#中的attribute，
都能将一些配置信息或元数据（metadata）与相关联的软件元素如类、方法、域等同放一处。
但配置文件不可能被完全取代，原因是多方面的：
有些信息是不宜放在源代码中的；与多个软件元素同时相关的信息最好统一管理；
配置文件的内容不会污染源代码，还能在运行期间被重新设置等。
此例也反映出实现局部化的困难所在：从不同逻辑层面来考察，便有不同的代码聚合方式，
但最终只能从中择一。


局部化原则还能导出DRY（Don'tRepeatYourself）原则，
从而实现了单点维护（singlepointofmaintenance）。理由是：重复代码的逻辑紧密度最高，按照局部化原则，
相应的物理紧密度也该最高——还有什么能比融为一体的密度更高呢？


既然代码的物理紧密度与逻辑紧密度是一致的，
那么逻辑关联度大的代码应该包含在同一个模块中，
否则它们的物理距离太远；
逻辑关联度小的代码不应包含在同一个模块中，否则它们的物理距离太近。
于是每个模块内部的关联度较高，模块之间的关联度较低。
故此，从局部化原则不仅能得出高内聚原则，还能得出低耦合原则。


还有一个更具体的内聚原则——单一职责原则（SingleResponsibilityPrinciple），简称SRP。该原则主张：一个类应当只有一个变更的理由。”


模块的每一种职责既是一个关注的焦点，也是一个潜在的变化点。因而，职责、关注点与变化点是三位一体的。
如果一个模块包含的所有元素——包括指令、数据的定义、其他模块的调用等——都在为完成同一个任务而工作，
那么这种内聚被称为功能内聚（functionalcohesion），是最理想的内聚


大多数类最初的目的还是很单纯的，可随着开发的深入，被塞进了越来越多的方法，渐渐地变得无所不能。

如果程序员由于认识不足而违背SRP，或者出于惯性、惰性等原因而不愿轻易地增加新的类，那是应当引以为戒的。
但有时违背SRP是情有可原的，毕竟类的职责难以被清晰地界定，关键还是看它们对变化的反应。
比方说，涉及表现形式的职责与涉及数据或逻辑的职责最好不要混为一体，
因为它们的变化方向几乎总是正交的。
这正是我们把负责序列化的toXml方法抽调到OrderSerializer类中的理由，
也是为什么MVC架构中的视图、3层结构中的表现层被单独隔离的原因。
反过来，如果发现两个职责总是联动的，改变其中的一个很可能会影响到另一个，
哪怕它们看似关联不大，也能名正言顺地聚合。

SRP让我们对OOP中的类有了新的理解。
一般认为，类是对现实世界中的对象或人类思维中的概念进行模拟和抽象的结果。
这种观点非常符合朴素的理论和直觉的认知，
对类的设计也具有一定的启发作用。但在实际编程中，它还是显得过于空泛。
程序员时常会困惑：究竟该为哪些对象或概念创建类？
创建以后，该为它赋予哪些属性和方法？
SRP我们提供了一个启示：每个类都是单一职责的抽象，也是单一变化的封装。
这表明：一个理想的类在其所在的抽象层次上，
既是一个最小的可重用单元，也是一个最小的可维护单元。


如果一些类违背了SRP，却因种种原因暂时不便修改接口，
我们还可用ISP——接口隔离原则（InterfaceSegregationPrinciple）来弥补。
比如，假设刚才的ShoppingCart类遵循接口原则，
通过ShoppingService接口为一些客户提供了服务，
直接重构该接口会导致这些客户无法工作，
这时可将其分割为3个超类型接口

把一个接口中的5个方法分给若干个接口中的方法
类只需继承所需要的接口不用实现原先接口的所有方法

ISP主张：不应强迫客户依赖那些它们不用的方法。
比如NewClient1只关心支付验证，NewClient2只关心购物信息，NewClient3只关心订单序列化。
假如它们直接依赖ShoppingService接口，那么一旦有关支付验证的方法发生改变，
NewClient1受到牵连固是在劫难逃，可NewClient2和NewClient3也被累及就未免太无辜了。
经过接口隔离，把一个总接口细分为几个更专门、内聚度更高的接口，上述问题便可得到解决。


这的确增加了一定的复杂性，是否值得取决于接口的关联程度、稳定程度、客户范围等因素。
如果接口的内聚度较低、稳定性较低、客户面较广，则进行接口隔离是非常必要的，即使付出一定的代价也在所不惜。
ISP还有一个诱人之处：它不仅能有效地减少接口变化带来的副作用，还能更方便地提供各种专门的实现以适应客户的需要。
假如NewClient1不满意ShoppingCart类的实现，程序员只须为它所依赖的PaymentValidator接口提供另一个实现类即可，
既不用对ShoppingCart类作任何改动，也不用费神实现ShoppingService中其他5个无关的接口。




SRP与ISP在保证高内聚的同时，也为低耦合作出了贡献。
假若一个类或接口有两组关联性不强的方法，那么依赖不同组的两个客户很可能本无关联，
却因依赖相同的类或接口而发生耦合。



总结➢耦合反映模块之间的关联程度，内聚反映模块内部的关联强度。它们是衡量软件设计质量的两个重要尺度。耦合度宜低，内聚度宜高。➢常见的8种耦合由高到低依次是：内容耦合、公共耦合、外部耦合、控制耦合、印记耦合、数据耦合、消息耦合和无耦合。



➢常见的8种内聚由低到高依次是：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、信息内聚和功能内聚。➢低耦高聚原则可保证软件的可理解性、可维护性、可重用性和可测试性。➢局部化原则是：让代码的物理紧密度与逻辑紧密度保持一致。➢局部化原则可导出模块化原则、关注点分离原则、DRY原则和低耦高聚原则。➢配置文件与元数据属性（如Java中的annotation、C#中的attribute）是两种不同的局部化策略，各有利弊。➢程序员的注意力和记忆力是有限的，局部化有助于保证代码的可读性和思维的连贯性。➢从不同逻辑层面来考察，便有不同的代码聚合方式，但最终只能从中选择一种局部化的策略。




➢SRP（单一职责原则）主张：一个类应当只有一个变更的理由。➢职责、关注点与变化点是三位一体的。➢类的粒度应与职责的粒度保持一致。➢在一定的抽象层次上，一个类最好是一个最小的可重用单元，也是一个最小的可维护单元。➢ISP（接口隔离原则）主张：不应强迫客户依赖那些它们不用的方法，多个专用的接口比单纯一个总接口更好。➢SRP提倡高内聚的类，ISP提倡高内聚的接口。同时，它们还有助于降低系统的耦合度。➢良好的设计往往导致低耦高聚，糟糕的设计往往导致高耦低聚。




保变原则

构建低耦高聚系统的法宝——保变（ProtectedVariations）原则[19]。
保变是指受保护的变化，以下将其与缩写PV换用。
该原则的内容是：找出预计的变化点或不稳定点，分配其职责以便用稳定的接口来包装。

保变原则确与单职原则一样，中心都是职责与变化。
不过从名称上就能看出，保变原则的着眼点更倾向变化，而单职原则的着眼点更倾向职责。
此外，前者侧重解决耦合问题，后者侧重解决内聚问题。

封装是实现PV的一种技巧和手段。
PV涵盖的范围很广，可以是任何软件实体，包括模块、组件、子系统乃至系统。
封装是在类级别的PV，或者说是数据抽象层的PV。
同理，子类型多态是接口级别的PV，或者说是多态抽象层的PV。

软件越复杂、寿命越长，可维护性越重要，因为软件维护是软件生命周期中耗时最长、耗资最多的一个阶段。

真正可重用的代码是很少变化的，
至少API的变化频率是极低的，就像类库那样。
或者这么说，如果一段代码与其客户代码在稳定程度上属于同一档次，
在维护人员上属于同一开发组，在发布版本上属于同一单元，那么与其说它具有可重用性，不如说是具有可共用性。
但这丝毫不妨碍它为降低系统复杂度、提高软件可维护性而作贡献。
事实上，越是接近客户需求前沿的类，越容易发生变化，稳定度就越低，有些修改是非常正常的。
因此，一味苛求高层代码具有高可重用性，不仅是不必要的，


总之，盲目追求可重用性而忽略可维护性，不能说是舍本逐末

一个增强软件可维护性的通用而有效的方法。
从这里，我们还可看出保变原则与间接原则是异曲同工的。
回顾一下，间接原则的一个典型应用是：为了解除两个模块之间的耦合，专门引入一个中间模块。
耦合并不总是有害的，只有当其中潜藏的变化明显不利于将来的维护时，才有消除的必要。
这个中间模块的作用，就是将此变化加以抽取和封装，并承担起中介的职责。

保变原则提倡变中求稳，更侧重可维护性；开闭原则提倡稳中求变，更侧重可重用性[

保变原则还暗含了迪米特法则（LawofDemeter，简称LoD），又称最少知识原则（LeastKnowledgePrinciple，简称LKP），

即不要与陌生人交谈（Don'tTalktoStrangers）。
具体应用到方法调用上，它要求一个对象的方法只能调用以下对象：该对象本身，即this（或self）；
该方法的参数；该方法内部创建的对象；该对象的直接组成对象，包括其属性及集合性属性中的元素。

职责转移，也是一种设计模式——委托（delegation）模式，同时还体现了间接原则。

朋友关系没有传递性。在常见的封闭型多层架构中，
上层只依赖于相邻的下层，不能越层请求服务，也是同样的道理。
每个模块都有清晰的逻辑边界和物理边界，但它的交际圈却没有。为了弥补这一缺憾，
迪米特法则对模块的交际圈作出了明确的界定。
如此一来，发生在模块上的变化受到了双层保护：
一层是模块自身的保护机制，一层是模块交际圈的保护机制。有了它们，系统任凭风吹浪打，也自岿然不动。


GRASP（GeneralResponsibilityAssignmentSoftwarePatterns/Principle）[21]，即通用职责分配原则。想必大家已经认识到，合理的系统应保证每个模块各司其职、各尽其责，既不尸位素餐，也不越俎代庖。



创建者原则建议：创建一个类的实例的职责应分配给那些包含、聚合、记录或密切使用该类的类，
或者拥有该类初始化数据的类。
这个原则非常自然，算得上是信息专家原则的一个推论，
但同时也在两个类之间建立了强耦合。
为此，可以专门设计一个工厂类，接管创建对象的职责——这便是著名的工厂模式（factorypattern）。
该工厂类无疑符合纯虚构原则，
因为工厂原本是不存在的。
再如，控制器原则建议：
把处理系统事件的职责分配给两种类，
一种是代表整体系统的类，符合信息专家原则；
一种是代表事件发生的用例场景（usecasescenario）的类，
符合纯虚构原则。还有一个典型范例是领域驱动设计（domain-drivendesign）中的服务（service）。
它是不同于实体（entity）和值对象（valueobject）的一种特殊的对象，不含任何状态（stateless），
唯一的职责是把模型中相关的实体或值对象组织起来，为客户提供一系列相关的服务。
每个服务都是一种行为而非实体、动词而非名词的抽象，也是纯虚构原则的体现。”


单一职责原则SRP（SingleResponsibilityPrinciple）一个类应当只有一个变更的理由
开闭原则OCP（Open-ClosedPrinciple）软件实体应对扩展开放，对修改封闭
里氏代换原则LSP（LiskovSubstitutionPrinciple）子类型必须能替代超类型
接口隔离原则ISP（InterfaceSegregationPrinciple）不应强迫客户依赖那些它们不用的方法
依赖反转原则DIP（DependencyInversionPrinciple）抽象不应依赖细节，细节应当依赖抽象


SOLID是类级别的设计原则，

而这6个是包（package）级别的设计原则

发布重用等价原则REP（Release-ReuseEquivalencyPrinciple）重用的粒度即是发布的粒度
共同闭包原则CCP（CommonClosurePrinciple）同在一个包中的类应对同类变化封闭
共同重用原则CRP（CommonReusePrinciple）同在一个包中的类一起被重用
无环依赖原则ADP（AcyclicDependenciesPrinciple）在包的依赖图中不允许有环存在
稳定依赖原则SDP（StableDependenciesPrinciple）朝着稳定的方向依赖
稳定抽象原则SAP（StableAbstractionsPrinciple）一个包的抽象度应与其稳定度相当

前3个是关于包的内聚原则，以解决包的颗粒度（granularity）问题；
后3个是关于包的耦合原则，以解决包的稳定度（stability）问题。”

➢保变（PV）原则：找出预计的变化点或不稳定点，分配其职责以便用稳定的接口来包装。➢保变原则的着眼点更倾向变化，侧重解决耦合问题；单职原则的着眼点更倾向职责，侧重解决内聚问题。➢封装是在类级别的PV，子类型多态是接口级别的PV。➢衡量一个软件的设计质量最重要的标准是可维护性。灵活性、可扩展性、可理解性、包括可重用性最终都是为了保证可维护性。➢保变原则针对软件维护的大敌——变化提出了通用而有效的方法。➢保变原则提倡变中求稳，更侧重可维护性；开闭原则提倡稳中求变，更侧重可重用性。➢迪米特法则又称最少知识原则，它对模块的交际圈作出了明确的界定，能提高系统的可维护性。➢保变原则可导出间接原则、迪米特法则等诸多设计原则，以及几乎所有的设计模式。

➢GRASP（通用职责分配原则）包括：信息专家原则、创建者原则、控制器原则、低耦合原则、高内聚原则、多态原则、纯虚构原则、间接原则和保变原则。➢信息专家原则建议：谁拥有完成职责所需的全部信息，谁就该负责。它使系统的整体功能比较均匀地分散于各个类之中，有利于系统的维护。➢纯虚构原则建议：将一组高内聚的职责集合分配给一个虚构的“行为”类（即不代表问题领域的概念），以支持低耦高聚。它是对信息专家原则的有效补充。➢SOLID是类级别的设计原则，包括：SRP（单一职责原则）、OCP（开闭原则）、LSP（里氏代换原则）、ISP（接口隔离原则）和DIP（依赖反转原则）。➢3个关于包的内聚原则：REP（发布重用等价原则）、CCP（共同闭包原则）、CRP（共同重用原则）。➢3个关于包的耦合原则：ADP（无环依赖原则）、SDP（稳定依赖原则）和SAP（稳定抽象原则）。➢本课最重要的7对关键词：分离与间接、控制与依赖、规范与抽象、服务与接口、职责与变化、内聚与耦合、维护与重用。




依赖注射包含两个方面的控制反转：一是组件把创建并管理所须依赖的控制权交给了其他模块；
二是组件在服务过程中反向调用来自应用层的（被注入的）依赖。DI容器一般主要强调前者，


依赖查找是主动获取依赖（依赖注射是被动获取依赖），

































