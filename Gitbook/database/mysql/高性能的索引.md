# 高性能的索引

索引 在MYSQL里叫做 键 KEY 是存储引擎快速找到记录的数据结构

最常见的B-Tree索引 按照顺序存储数据 

索引三个优点
1 大大减少服务器需要扫描的数据量
2 帮助服务器避免排序和临时表
3 将随机I/O 变成顺序I/O

非常小的表 全表扫描更高效
中到大型的表 索引有效
特大的表 建立和使用索引的代价增加

索引列不能是表达式的一部分 也不能是函数的参数

创建前缀索引  前缀长度为7
alter table city_demo add key (city(7));

将选择性高的列放在索引的最前列

没有一个放之四海皆准的法则

聚簇 表示数据行和相邻的键值紧凑的存储在一起
一个表只能有一个聚簇索引

尽可能按照主键顺序插入数据 
对于高并发工作负载 主键顺序插入可能会造成明显的争用 并发插入导致间隙锁竞争

索引覆盖 一个索引包含所需查询的字段值  使用索引直接获取列的数据 不需要读取数据行

由于HASH索引等不存储索引列的值 所有MYSQL只能用B-TREE索引来做覆盖索引

索引覆盖查询 时 EXPLAIN 的EXTRA列 可以看到USING INDEX 信息

如果查询了所有的列 没有任何索引可以覆盖所有的列
MYSQL在索引中做最左前缀的LIKE比较  如果是通配符开头的LIKE查询 存储引擎无法做出比较

延迟关联
SELECT * FROM products JOIN ( select prod_id from products where actor="sean" and title like "%apple%") as t1 on t1.prod_id = procucts.prod_id

索引扫描排序
MYSQL可以使用同一个索引 既满足排序 又满足查找行 设计时尽可能满足这样俩种任务
只有索引的列顺序和 order by 子句的顺序完全一致 并且所有列的排序方向 倒序 正序 都一样 才能使用索引来对结果排序
如果order by 子句不满足索引最左前缀的要求 如果where 和 join 对这些列指定了常量 可以弥补索引不足
EXPLAIN 出来的TYPE列的值为Index 说明mysql使用了索引扫描来做排序 

MYSQL 唯一限制和主键限制 都是通过索引实现的

沉余索引
索引（A,B） 再创建索引（A）就是沉余索引 因为这只是前一个索引的前缀索引 创建(B,A)(B)就不是沉余索引
尽量扩展已有索引 而不是创建新索引

索引越多 插入索引越慢 Insert update delete 变慢

创建索引时 看下where语句中最频繁的 尽可能重用索引 而不是建立大量的组合索引 
尽可能把需要做范围查询的列放到索引的后面（比如 > in 范围查询）以便优化器 使用尽可能多的索引项

翻页靠后查询也是非常慢 limit 1000000,10;随着偏移量的增加 MYSQL需要大量时间扫描需要丢弃的数据。
限制用户翻页的数量

check table 检查是否发生表损坏 
repair table 修复损坏的表

大部分使用B-TREE索引

单行访问慢 使用索引创建位置引用 提升效率
按顺序访问数据快 顺序I/O比随机I/O快 不需要额外的排序
索引覆盖查询快 一个索引 包含的查询所需的所有列 存储引擎就不需要再回表查询





