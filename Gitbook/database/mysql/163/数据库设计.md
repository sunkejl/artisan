# 数据库设计

[课程地址](http://mooc.study.163.com/learn/NEU-1000080001?tid=2001223005#/learn/content?type=detail&id=2001414085)

schema 设计

表的设计
根据查询需要设计好索引

建立合适的索引 更新尽可能使用主键或唯一索引
主键用自增id!
索引覆盖扫描 用户名 密码 设置为联合索引 每次返回密码不需要回表 减少IO

反范式 最频繁的操作（频繁join增加随机IO） 留下冗余字段（俩个表都去存username） 代价是修改会修改更多表
 
拆分大字段 如 博客 文章题目 作者 和 内容分开

避免字段过多 过长（30个以上算比较多）
一次没必要获取那么多列数据
行过长导致表数据页记录变少 范围扫描性能降低
更新数据页代价增加
16K页最多放2行，可能出现行迁移 随机IO更高
表体积大 维护 迁移困难
拆分表 
 
limit 100 offset 100000  会扫描前100000条 减少IO扫描 是优化根本
避免limit + offset 过大  通过 id>100 limit 100 操作 从100行开始扫描 每次记录前一页最后的Id 风险id空缺

禁止100页以后的操作
 
mysql查询 避免io操作
 
热点数据 如置顶贴 单独建一张表存，提高读的效率
 
推送消息 由推改成拉去数据
 
定时统计表 单独记录某个时间的总量 和 时间 求和的时候从某个时间开始累加
 
insert加触发器 避免全局算count 比如1亿条

展示动态交易额，用定时脚本去跑数据sum count 压力不大  实时性要求不高的情况 

insert触发器 新增 去统计表+1 缺点触发器加入影响insert效率

缓存+1 缺点 断电丢失数据 

自增id 去统计总数  删除的时候不真删除

可扩展性设计

1老数据迁移出数据库
2分库分表
3水平拆分

在主从表上建立不同索引 将一些统计的访问 导向从库 读写分离

表的第一个timestamp字段 写入的时候 没指定值 自动写入系统时间戳 记录发生更新都会自动更新

加入is_deleted字段标记位 彻底去掉delete方法


# 业务审核和优化


[课程地址](http://mooc.study.163.com/learn/NEU-1000080001?tid=2001223005#/learn/content?type=detail&id=2001452011)

业务审核 类似 code review

上线前 审核
上线后 通过监控发现问题 


设计审核：
表 字段命名是否合规 表 字段名都是小写 不能是拼音组成 表名前缀带tb_

字段类型 长度设计是否适当  char还是varchar
表关联关系是否合理  
主键 更新时间 保留字段是否符合要求 
约束 默认值 等配置是否恰当 非空约束 
了解业务  表数据量 增长模式  哪些表存大量数据 
数据访问模式  均衡度   一次插入多次更新 还是 大量插入 用主库和从库来把最近记录和老记录分开
                     均衡度  字段不均衡 索引效率会有影响 
表是否要分区   定期导入历史库 开放给线下查询

SQL语句审核：
sql语句的执行频率  执行频率高 导致并发高
表上是否有合适的索引
单次执行的成本  需要扫描的记录 比如1K条 就说明开销较大 
执行模式 锁情况分析
关注事务上下文

什么时候需要审核

开发阶段 上线前 

业务变更 线上更
新表 和 SQL上线
查询条件变化
查询频率变化
数据量规模变化










 
 

