多态机制

多态类型

继承的主要用途不是代码重用，而是代码被重用。这依赖于两个前提，
一个是在语义上遵循里氏代换原则，
另一个是在语法上支持多态（polymorphism）机制。因此不妨说，对于静态类型语言来说，继承是多态的基础，多态是继承的目的。”




子类型多态的效果——让不同的实现代码应用于相同的场合。假设没有多态机制，这种效果就只能靠if/else或switch之类的条件语句才能实现，非常地痛苦。”




职责分离的好处。存储与加密本是两样不相干的工作，必要时可以合作，但平时最好分开管理，符合‘低耦合、高内聚’的原则。”



策略模式（strategypattern或policypattern）的基本思想是：把一个模块所依赖的某类算法委交其他模块实现。
传入不同的类，打到不同的目的

不要要所有类继承一个父类，分离出多个父类，来组合



当一个类的某个方法接收了此种类型的参数，实质上就采用了策略模式。”





模板方法模式与策略模式非常神似，都是把一个类的可变部分移交给其他类处理。”



的。模板方法模式突出的是稳定坚固的骨架，策略模式突出的是灵活多变的手腕。不妨拿国家政策作比：一个强调对内要稳，老一辈制订了大政方针，下一代必须在坚持原则的前提下进行完善；一个强调对外要活，不能或不便自行开发的技术不妨从国外引进。”




模板方法模式可看作控制反转的特例，策略模式与依赖注射（DependencyInjection）也异曲同工。



通过构造方法‘注射’进来的[4]。当然策略只是一种特殊的依赖，是自内而外的——将算法抽出来外包；依赖注射的机制更复杂、涵盖面更广，是自外而内的——从外部嵌入定制功能。



3种形式的多态：基于类继承的多态、基于接口继承的多态和基于模板的多态。



通用多态（universalpolymorphism）。此外，还有一类特别多态（ad-hocpolymorphism），常见有两种形式。
一种是强制多态（coercionpolymorphism），即一种类型的变量在作为参数传递时隐式转换成另一种类型，
比如一个整型变量可以匹配浮点型变量的函数参数。
另一种就是重载多态（overloadingpolymorphism），它允许不同的函数或方法拥有相同的名字。

特别多态浅显易懂，其重要性与通用多态也不可同日而语，
故不在我们关注之列。只是要注意一点，
正如子类型应遵守超类型的规范，同名的函数或方法也应遵守相同的规范。如果为贪图取名方便而滥用重载，早晚因小失大。





总结➢在静态类型语言中，继承是多态的基础，多态是继承的目的。➢多态结合了静态类型的安全性和动态类型的灵活性。➢多态可分为通用多态和特别多态两种。➢通用多态主要包括参数多态和包含多态（或子类型多态）。它们都是为了克服静态类型过于严格的语法限制。➢特别多态主要包括强制多态和重载多态。➢参数多态是静态绑定，重在算法的普适性，好让相同的实现代码应用于不同的场合。➢包含多态是动态绑定，重在接口与实现的分离度，好让不同的实现代码应用于相同的场合。



➢策略模式授予客户自由选择算法（策略）的权力。➢模板方法模式重在稳定坚固的骨架，策略模式重在灵活多变的手腕。➢合理地运用基于类继承的多态、基于接口继承的多态和基于模板的多态，能增强程序的简洁性、灵活性、可维护性、可重用性和可扩展性。



抽象类型


具体类型是创建对象的模板，抽象类型是创建类型的模块。
一个是为对象服务的，一个是为类型服务的。
显然，后者的抽象性正是源自其服务对象的抽象性。
就拿刚才的实例来说，模板方法模式中的Authenticator类是抽象的，是为创建子类型SimpleAuthenticator、ShalAuthenticator等服务的；
策略模式中的Authenticator类是具体的，是为创建对象服务的，
但它合成的两个接口KeyValueKeeper和Encrypter又是为创建算法类型服务的。
值得注意的是，不要把抽象类型与抽象数据类型（ADT）混为一谈，
后者的抽象指的是类型的接口不依赖其实现。
或者说，抽象数据类型的核心是数据抽象，而抽象类型[7]的核心是多态抽象。





抽象类型就只有接口（interface）和抽象类（abstractclass）



接口的主要目的是创建多态类型，本身不含任何实现。
子类型通过接口继承只能让代码被重用，
却无法重用超类型的实现代码。
抽象类可以重用代码，可又有多重继承的问题。





合成是一种解决办法，但也不是没有缺陷。首先，合成的用法不如继承那么简便优雅，这也是许多人喜欢用继承的主要原因；其次，合成不能产生子类型，而有时这正是设计者所需要的；再次，合成无法覆盖基础类的方法，也无法访问它的protected成员；最后，却可能算最大的缺点是：合成的基础类只能是具体类型，不能是抽象类型。”



具体类型的主要任务是创造新对象，如果用作合成或继承的基础类，等于是又承担了原本抽象类型的任务——创造新类型。



一个类的服务应该有纯粹性和完备性。
一方面，人们希望创造的新对象无所不能，因此更看重服务的完备性，
倾向它包含尽可能多的功能；
另一方面，人们又希望创造的新类型有所不依，
因此更看重服务的纯粹性，倾向它包含尽可能少的功能。”
妥协的结果是，一个新类型往往只用到基础类型的部分功能，
却可能受到其他功能变动的影响。
虽然这种影响在良好的封装之下会大大削弱，但也难以完全消弭。



抽象类的意义就在于：父类推迟决定，让子类选择实现方式。
‘推迟’二字道出了抽象类型除创建类型之外的另一功用：提供动态节点。
如果是具体类型，节点已经固定，没有太多变化的余地。
反过来，要使节点动态化，一般通过多态来实现。
由此可见，抽象类型常常与多态机制形影不离。”
用模板方法模式实现的Authenticator类将关键的方法交给
子类SimpleAuthenticator或ShalAuthenticator处理，
用策略模式实现的Authenticator类将关键的方法交给
内嵌接口KeyValueKeeper和Encrypter的实现类处理。

后者的两次接口继承比前者的一次实现继承多了一个动态节点，
因而更加灵活。

这也是为什么一个需要（M×N）个实现类，验证和存储都用一个类来处理,

一个只要（M+N）个的原因。验证和存储分开成俩个类来处理

模板方法模式：newSha1Authenticator()
策略模式：newAuthenticator(newMemoryKeeper(),newSha1Encrypter())

接口继承不是为了重用，而是为了被重用。”












描述：如果把OOP系统看作民主制社会，每个对象是独立而平等的公民，
那么封装使得公民拥有个体身份，
继承使得公民拥有家庭身份，
多态使得公民拥有社会身份。补充一下，其中的继承主要指类继承，多态主要指接口继承带来的多态。




对象每多一种社会身份，便多一条与外界交流的渠道。为什么遮遮掩掩地不肯以本来面目示人呢？非是羞于见人，盖因一般的具体类型在公共场合是不为人知的，只有少数核心库里的核心类是例外。即使侥幸被认识，也难被认可，因为那会以代码的复杂度和耦合度为代价。社会身份则不然，它远比一般的个体身份更容易被接受。”


一般的具体类型不为人广知道，不确定如何用


提到‘针对接口编程’的基本原则。它有一种建立于数据抽象之上的形式，
能让用户只关心抽象数据类型的API接口而无视其具体实现。
不过，它至少有两大局限。其一，虽然在接口不变的情况下，
实现代码的改变不会影响客户代码，但仍须要重新编译，
对于需要头文件的C++来说则需要更多的编译链接时间。
其二，虽然相同的接口可以有多种实现方法，但它们不能同时并存，
更无法动态切换。
于是，另一种建立于多态抽象之上的形式应运而生。
它把抽象数据类型隐藏在抽象类型的背后，
从而提升了抽象接口。同一个抽象接口允许有多种实现并存，
且能动态切换，新增、删除或修改某种实现也不会导致其他代码的修改或重新编译。
方才我们从主体类的角度来看，它的对象尽量以社会身份参与社会活动；
现在再从客户类的角度看，它会尽量召集有社会身份的对象。
两相结合，以社会身份而非个人身份作为公民之间联系的纽带，
正是针对接口而非实现来编程的社会现实版。


“排除设计不良的因素，没有抽象超类型的具体类型最常见的有两种可能。一种是与世隔绝，一辈子几乎足不出户，至多在小圈子里活动。典型的有非公有类、内部类、局部类，等等。一种是名满天下，他的脸就是一张天然名片，他的个人身份也就是社会身份。典型的有基本数据类型、字符串类型、日期类型等通用数据类型及特定领域的通用数据类型。可见，个人身份与社会身份并无绝对的界限。同样，家庭身份与社会身份也有交合之处，正如名门望族也可成为社会身份一样。








因此，我们谈到的社会身份，不必拘泥于接口，甚至不必限于抽象类型，关键是该类型是否具备了足够的通用性和规范性、稳定性和独立性、灵活性和专业性。还是应了那句话：抽象不是目的而是手段。再拿现实社会说事，每种社会身份都代表了个体与社会缔结的一种契约，它有如下的特点：独立而稳定——先于个体而存在，且不随个体的变化而变化；公开而权威——为人所知、为人所信；规范而开放——制定的协议标准明确，且允许个体在遵守协议的前提下百花齐放。毫无疑问，推行契约制将使社会大受其惠。首先，相同身份的个体可相互替换、新型个体可随时加入，而且不会影响整体框架和流程，保证了系统的灵活性和扩展性。其次，整体不因某一个体的变故而受冲击，保证了系统的稳定性和可靠性；最后，个体角色清晰、分工明确，保证了系统的规范性和可读性。”



具体地说，个体身份对应的规范抽象借助封装，以数据抽象（dataabstraction）的形式出现；家庭身份对应的规范抽象借助继承，以类型层级（typehierarchy）的形式出现；社会身份对应的规范抽象借助多态，以多态抽象（polymorphicabstraction）的形式出现。至此，我们从行为和规范两个角度分别诠释了OOP的3大特征与公民的3大身份之间的关系。这也非常合乎情理：一个合理设计和实现的类，其对象的行为与规范本应保持一致。”



接口继承是静态的，而角色却可能是动态的。比如，学生毕业后变成职员，职员升迁后变成经理，等等。对于静态类型语言来说，这类问题的解决单靠接口继承是不够的，还需要利用合成



等手段，或者利用前面提到的其他抽象类型如mixin或trait。”



抽象类的出现，让两种不同角色的类在语法上有了明确的界定：
具体类描述对象，重在实现；抽象类描述规范，重在接口。
这种分工降低了用户与实现者之间的耦合度，大大减少了代码的维护成本及编译时间[14]。
由于抽象类不是为了创建对象，它的实例化自然是没有意义的。
又由于它是接口规范，在子类没有实现其所有规范之前，是不能实例化的，
否则规范岂不成了一纸空文？在没有抽象类的语法之前，要实现类似的功能，
唯一的办法是：在本该抽象的方法被调用时强行中止程序。
烦琐丑陋不说，还只能在运行期间捕捉错误。
在纯虚函数（purevirtualfunction）——相当于Java和C#中的抽象方法——被引入之后，
任何含有抽象方法的类都是抽象类，编译器将保证它不会被实例化。”





从具体类中分离出抽象类是一次质的飞跃，从抽象类中进一步地分离出接口则是另一次飞跃。



一个抽象类可以没有任何实现，但也随时可以加入实现。接口则不同，永远都不能有实现代码。这正是引入关键字interface的目的，明明白白地表明：此乃规范集合所在，杜绝任何自以为是、画蛇添足的实现。初看似乎不合常理：这不是自缚手脚、自废武功吗？殊不知自由源于自制。许多人为了贪恋一点点代码重用，总忍不住把一些实现放在本该只是规范的地方。一来，这模糊了规范与实现的界限，背离了接口与实现相分离的设计初衷。要知道，再完美的实现都有改动的余地，将其捆绑到规范中只会增加不稳定因素；再完美的实现也不应该影响其他的实现，先入为主只会降低灵活性。二来，带有实现的抽象类无法用于合成，必须通过类继承才能起作用，而实现继承的弊端我们已经见识过了。在有些情况下，规范的实现比较复杂，需要渐进实现，保留一些中间状态的抽象类也是合理的，但最初的接口最好保留。总不能因为有了模具半成品，就抛弃模具规格吧？以JavaCollectionsFramework为例，既规范了Collection、Set、List、Map等接口，又为这些接口提供了抽象类和具体类，从而给了用户3种选择：直接利用具体类、扩展抽象类、直接实现接口，方便程度递减而灵活程度递增。”



一般人重视实现轻视规范

先从本性上看：接口是一套功能规范集合，因此相同的接口代表相同的功能，多表示‘can-do’关系，常用后缀为‘-able’的形容词命名，如Comparable、Runnable、Cloneable，等等。接口一般表述的是对象的边缘特征[15]，或者说一个对象在某一方面的特征，因此能在本质不同的类之间建立起横向联系。由于一个对象可拥有多方面的角色特征，故而可有多种接口。与之相对地，抽象类是一类对象的本质属性的抽象，因此相同的抽象基类代表相同的种类，多表示‘is-a’关系，常用名词命名。抽象类一般表述的是对象的核心特征，只能在本质相同的类之间沿着继承树建立起纵向联系。由于一个对象通常只有一个核心，故而只能有



一种基类。再从目的上看：接口是为了规范重用，让一个规范有多种实现，看重的是可置换性；抽象类主要是为了代码重用[16]，能逐级分步实现基类的抽象方法，看重的是可扩展性。”



很大。接口由于是被广泛采用的规范，相当于行业标准，一经确立不能轻易改动。一旦被广泛采用，它的任何改动——包括增减接口、修改接口的签名或规范——将波及整个系统，必须慎之又慎。抽象类的演变则没有那么困难，一则它在系统中用得没有接口那么广泛，更多地是家庭身份而非社会身份；二则它可随时新增域成员或有默认实现的方法成员[17]，所有子类将自动得以扩充。这是抽象类的最大优点之一。不过接口也有抽象类所不具备的优点，虽然自身难以演化，但很容易让其他类型演化为该接口的子类型。



➢具体类型是创建对象的模板，抽象类型是创建类型的模块。➢抽象数据类型的核心是数据抽象，而抽象类型的核心是多态抽象。➢抽象类型除了接口和抽象类外，还有mixin、trait等，它们用来克服以下问题——合成的缺陷：



用法不如继承那么简便优雅；不能产生子类型；无法覆盖基础类的方法，也无法访问它的protected成员；不能以抽象类型为基础类。具体类型的矛盾与缺陷：作为创造对象的单位，功能越多越好；作为可重用的单位，功能越少越好。不宜被继承。接口的矛盾与缺陷：客户类希望它提供尽可能多的服务；实现类希望尽可能少的实现代码。无法代码重用。抽象类的缺陷：



接口无法代码重用，多重类继承或复杂晦涩或未获支持。➢mixin的特点：抽象性和依赖性；实用性和可重用性；专一性和细粒度性；可选性和边缘性。➢在设计阶段，从具体需求中构建出抽象模型，此时抽象类型尤为关键；在实现阶段，根据抽象模型来完成具体实现，此时具体类型更为重要。➢抽象类型除了能创建类型外，还能提供动态节点，以增加软件的灵活性和可扩展性。➢社会身份代表了个体与社会缔结的一种契约，具有独立、稳定、公开、权威、规范、开放等特点。➢以社会身份作为公民之间联系的纽带，以接口类型作为对象之间联系的纽带。➢系统中广泛用于模块之间通信的数据类型相当于社会身份，提倡使用接口类型。但也不必拘泥，甚至不必限于抽象类型，关键是要确保该类型的通用性、规范性、稳定性、独立性、灵活性和专业性。➢个体身份对应的规范抽象借助封装，以数据抽象的形式出现；家庭身份对应的规范抽象借助继承，以类型层级的形式出现；社会身份对应的规范抽象借助多态，以多态抽象的形式出现。➢从具体类中分离出抽象类是一次质的飞跃，从抽象类中分离出接口则是另一次飞跃。➢接口与抽象类的语法区别：接口不能提供实现但能多重继承，抽象类则正相反；接口只能包含公有的、非静态的、抽象的方法成员，抽象类则无此限制。➢接口与抽象类的语义区别：接口是一套功能规范集合，相同的接口代表相同的功能，多表示“can-do”关系，一般是对象的边缘特征，在本质不同的类型之间建立横向联系；抽象类是一类对象的本质属性的抽象，相同的抽象基类代表相同的种类，多表示“is-a”关系，一般是对象的核心特征，在本质相同的类型之间建立纵向联系。接口看重规范重用和可置换性；抽象类看重代码重用和可扩展性。




➢接口与抽象类的演变：抽象类的演变较为容易；接口自身很难演变，但很容易让其他类型演变为它的子类型。➢标记接口除了能定义类型外，还可作为类型元数据的载体。





构造方法‘注射’constructorinjection，另外两种常用的注射方法是setterinjection和interfaceinjection。



由于类继承同时也继承了接口，抽象类也能规范重用，但更侧重代码重用。






