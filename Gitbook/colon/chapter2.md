编程范式
Programming paradigm
编程风格

命令式编程（imperative programming）
用命令式编写的程序由命令序列组成，

过程式编程（procedural programming）
是指引入了过程（procedure）、函数（function）或子程序（subroutine/subprogram）的命令式编程。

声明式编程（declarative programming）
顾名思义，声明式编程由若干规范（specification）的声明组成的，
即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。
声明式编程是人脑思维方式的抽象，
即利用数理逻辑或既定规范对已知条件进行推理或运算。

声明式编程发轫于人工智能的研究，
主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。
其中，函数式编程将计算描述为数学函数的求值，
而逻辑式编程通过提供一系列事实和规则来推导或论证结论。

命令式语言提倡迭代而不鼓励递归，早期的Fortran甚至都不支持递归。
一则迭代比递归更符合命令式的思维模式，因为前者贴近机器语言而后者贴近数学语言；
二则除尾递归（tail recursion）外，一般递归比迭代的开销（overhead）大。
相反，声明式语言提倡递归而不支持迭代。
就语法而言，它不允许迭代中的循环变量；
就视角而言，迭代着眼微观过程而递归着眼宏观规律。

命令式把程序看作一个自动机，输入是初始状态，输出是最终状态，
编程就是设计一系列指令，通过自动机执行以完成状态转变；

函数式把程序看作一个数学函数，输入是自变量，输出是因变量，
编程就是设计一系列函数，通过表达式变换以完成计算；


➢命令式编程通过一系列改变程序状态的指令来完成计算，
声明式编程只描述程序应该完成的任务。
命令式编程模拟电脑运算，是行动导向的，关键在于定义解法，即“怎么做”，因而算法是显性而目标是隐性的；
声明式编程模拟人脑思维，是目标驱动的，关键在于描述问题，即“做什么”，因而目标是显性而算法是隐性的。

➢函数式编程通过数学函数的表达式变换和计算来求值。

➢逻辑式编程通过一系列事实和规则，利用数理逻辑来推导或论证结论。

➢命令式编程中的变量代表抽象化的内存，所存内容可能改变。声明式编程中的变量代表抽象化的符号，所指对象一般不会改变。

➢声明式编程专注问题的分析和表达而不是算法实现，不用指明执行顺序，一般没有或极少有副作用，也不存在内存管理问题。
这些都大大降低了编程的复杂度，同时也非常适合于并发式计算。

➢编程语言的流行程度与其擅长的领域密切相关。函数式语言和逻辑式语言擅长基于数理逻辑的应用，命令式语言擅长基于业务逻辑的、尤其是交互式或事件驱动型的应用。



函数是被动的实体，对象是主动的实体。


OOP利用继承与多态来增强可维护性、可扩展性和可重用性。

过程式编程的理念是以过程为中心，自顶向下、逐步求精。
OOP则正相反，以数据为中心，自底向上、逐步合并。

过程式编程自树根向下，逐渐分支，直到每片树叶，类似数学证明中的分析法，即执果索因的逆推法；
OOP则从每片树叶开始，逐渐合并，直到树根，类似数学证明中的综合法，即执因索果的正推法。

OOP以对象为基本模块单位，而对象是现实中具体事物和抽象概念的模拟，这使得编程设计更自然更人性化。

OOP最大的卖点是其高度的可重用性，相比其他范式却并不具明显优势，但它更接近人类的认知模式，
编程者更容易也更乐于用这种方式编程，这是它深入人心的一个重要原因。
比较一下两种用法：牛吃（草）与吃（牛，草），哪种更接近人类思维？

如果把牛换成狗，那么一个是狗吃屎，一个是吃狗屎。

过程式编程的模块以函数为单位，
OOP的模块以对象为单位
二者的区别是：
函数是被动的实体，对象是主动的实体。

过程式程序的世界是君主制的，主函数是国王，
其他函数是臣民，等级分明，
所有臣民在听命于上级的同时也对下级发号施令，
最终为国王服务；

OO程序的世界是民主制的，所有对象都是独立而平等的公民，
有权利保护自己的财产和隐私并向他人寻求服务，同时有义务为他人提供承诺的服务，
公民之间通过信息交流来协作完成各种任务。
更进一步地，
封装使得公民拥有个体身份，须要对自己负责；
继承使得公民拥有家庭身份，须要对家庭负责；
多态使得公民拥有社会身份，须要对社会负责。

过程式程序的世界是君主制的；
OO程序的世界是民主制的。



OOP大多是命令式的，但也有函数式的和逻辑式的OO语言。




OOP的核心思想可以归纳为：以数据为中心组织逻辑，将系统视为相互作用的对象集合，并利用继承与多态来增强可维护性、可扩展性和可重用性。

OOP既不能脱离其他范式，也绝非适用于一切应用。

可维护性、可扩展性和可重用性是所有范式和语言的共同目标，并非OOP所独有。

与其说OOP更具重用性，不如说更具易用性。

过程式编程以过程为中心，自顶向下，逐步求精。

对象式编程以数据为中心，自底向上，逐步合并。
过程式程序的世界是君主制的，OO程序的世界是民主制的。

封装使得对象拥有个体身份，继承使得对象拥有家庭身份，多态使得对象拥有社会身份。



并发式编程（concurrent programming）


并发式编程中以进程（process）或线程（thread）为基本单位。尽管它们有很大的差异，但为简明起见，这里不加区分地交替使用两个术语。

没有多处理器，是不是可以利用多台单处理器的主机同时运算呢？

真正的并发式编程，绝不只是调用线程API或使用synchronized、lock之类的关键字那么简单。

浏览器加载文字和加载图像也应分开在不同的线程，

并发式编程以资源共享与竞争为主线

意味着程序设计将围绕进程的划分与调度、进程之间的通信与同步等来展开。

合理的并发式设计需要诸多方面的权衡考量。

软件易于重用、维护、测试；
公平有效地利用资源，优化程序性能如增大吞吐量、减少响应时间、提高效率等；
保障进程安全，防止竞态条件（RaceCondition）；
保持进程活性，避免死锁、饥饿、活锁、资源枯竭等；
减少锁开销、上下文切换等带来的性能损失；妥善处理多进程在算法、调试等方面带来的复杂性。

在究竟是在语言级别上支持并发，还是交由操作系统处理的问题上


如果将程序系统视作公司，
那么并发式系统是产品型公司，每个进程是一名工人，其职责是执行单一任务；

对象式系统是服务型公司，每个对象是一名服务员，其职责是提供系列服务。

过程式：以过程为模块的君主体系，模块之间互相授命与听命。

函数式：以函数为模块的数学体系，模块之间互相替换与合成。

逻辑式：以断言为模块的逻辑体系，模块之间互相归纳与演绎。

对象式：以对象为模块的民主体系，模块之间互相交流与服务。

并发式：以进程为模块的生产体系，模块之间互相竞争与合作。

并发式编程以进程为导向，以任务为中心，以资源共享与竞争为主线。

并发式编程有助于提高运行效率、充分利用资源、提高软件的响应能力、改善用户体验、保证公平竞争，同时以进程为单位将系统模块化，更加真实地模拟现实世界。

合理的并发式设计应该做到：软件易于重用、维护和测试；有效地利用资源，优化程序性能；保障进程安全和活性；减少性能损失和复杂度。

对象式和并发式在传统编程的基础上，分别从不同的方向进行拓展：
对象式在数据类型上进行推广——允许运算作为数据类型的成员；
并发式在执行顺序上进行推广——

所谓基于对象的，有两种不同的涵义。
一种指“限制版”的OOP，即具备对象概念，但不具备OOP的一些其他特征，如继承或多态等。
Visual另一种指基于原型的（prototype-based），或者说基于实例的（instance-based），
而不像通常OOP是基于类的（class-based）。Java-Script、NewtonScript、MOO等语言即属此类。

