继承机制

继承（inheritance） 是OOP作为一个编程范式所具备的最显著特性

继承与继承还不一样
有的只继承实现
有的只继承接口 interface 
有的既继承实现又继承接口

extends某class来表示类继承（class inheritance）
这应该是既继承实现又继承接口

用implements或extends某interface来表示接口继承（interface inheritance）
这是只继承接口
因为继承使得子类自动拥有父类的属性和方法

实现继承消费可重用的旧代码
接口继承生产可重用的新代码

继承也被称为子类化（sub classing）
接口继承进而被称为子类型化（sub typing）


先区分两个概念：子类（subclass）和子类型（subtype）
子类不一定是子类型

子类型的关键是可代换性（substitutability）
具体地说，类型A的子类型B应该满足下面的条件
将程序中类型A的对象置换为类型B的对象，不会影响程序的合理性和正确性
这就是著名的里氏代换原则（Liskov Substitution Principle），简称LSP
派生类（子类）对象能够替换其基类（超类）对象被使用

里氏代换原则的本质正是为了保证规范抽象

里氏代换原则让规范抽象不再局限于单个类型，而延伸到整个类型族上
并且规范是向上兼容（forward compatible）的
说得通俗些，这就好比一个人作出某项承诺，他的子子孙孙都得遵守，只能加强，不能削弱

当客户用到某一抽象类型时，才能完全不用关心其实现的具体类型，只须关心该抽象类型的规范即可
与数据抽象类似，这也是一种接口与实现的分离
只是接口所在的类型与实现所在的类型不再相同
相应的代码也不再粘合一处
不妨认为这是一种推广形式的数据抽象——多态数据抽象（polymorphic data abstraction），或者简称多态抽象

所谓多态，意指一种类型可能具备多种类型的形式
多态抽象是建立在类型层级的基础上的
或者说
接口继承在遵循里氏代换原则的前提下
通过接口重用达成规范重用，保证了多态抽象，进而维护了开闭原则
让客户一劳永逸地享受接口服务而无后顾之忧


多态
```php
publicfunction__construct(Animal$animal){
$this->_animal=$animal;//传入对象不需要if判断直接调用
}
```
接口继承和实现继承都应该复合里氏替换

因为实现继承在继承实现的同时也继承了接口
按理也应继承接口的规范
接口的继承能让代码被重用
如果只是为了重用基类的代码
并不希望重用它的接口
那就应该采用合成而不是类继承的方式

里氏代换原则不过是语法与语义相符原则的一个推论
顺便再提两个与常识相左的观点
与其说继承是一种实现的技巧
不如说是一种规范的技巧；与其说继承是一种is-a或is-a-kind-of的关系
不如说是一种behaves-like-a或is-substitutable-for的关系

is-a的说法无论从英文还是从中文来看，都过于笼统，容易产生歧义

is-a只能作为判断继承关系的一个必要条件，但不能作为充分条件
继承的关键在于可代换性，即遵循接口的规范
behaves-like-a表明一个子类型的行为表现正如超类型（supertype）一样

类是实现，类型是接口

同样一个词汇，在不同的层面、不同的角度和不同的上下文中有不同的意义。这也算是一种词语重用

规范抽象时，提到了接口与实现分离的两种方式
一个作为抽象数据类型（ADT）的类
通过数据抽象和封装机制而被划分为接口与实现两个部分
此时的接口也就是人们常说的API，是类向外界提供服务的窗口

另一方面，一个类又可以通过多态抽象和继承机制而拥有多种抽象类型
主要指关键字interface所代表的类型
相对于这些抽象类型而言，类又是具体的

在针对接口编程（Programming to an Interface）的原则下，类往往不是以其本来面目出现的
而是以某种抽象类型的身份来提供服务从这个意义上说
抽象类型是接口，类是实现

OOP将现实中的概念抽象映射为程序中的类型
继承机制进一步将概念的分类体系（taxonomy）映射为类型的层级结构（hierarchy）
使得对象模型能更逼真地模拟现实世界
人们能更有效地组织和管理类型系统，也更容易理解和交流彼此的设计思想

➢从子类到超类的泛化，是一种概念抽象的过程
从超类到子类的特化，是一种概念细化的过程
两种过程在设计中往往是交替采用的

➢泛化是一种概念关系，继承是一种语言机制

➢继承有3类
只继承实现（如C++中非公开继承）
只继承接口（如Java和C#中继承interface）
既继承实现又继承接口（如Java和C#继承class）
后两种分别又被称为接口继承和实现继承

➢实现继承消费可重用的旧代码
接口继承生产可重用的新代码
后者更符合OOP“自底向上”的设计理念

➢设计类时要有历史责任感——履行所有超类型所承诺的职责
要有主人翁精神——多考虑如何为其他类提供服务

➢子类型具有可代换性

➢里氏代换原则让规范抽象从单个类型扩展到类型族

➢接口继承在遵循里氏代换原则的前提下
通过接口重用达成规范重用
保证了多态抽象，进而维护了开闭原则
让客户代码不用修改就能得到扩展

➢由于实现继承在继承实现的同时也继承了接口
故也应遵循里氏代换原则
这既是一种义务，也是一种权益

➢语法与语义应尽可能地契合，以减少代码中的逻辑隐患

➢继承主要是一种规范的技巧，而不是一种实现的技巧

➢is-a或is-a-kind-of是判断继承关系的必要条件，而非充分条件

➢继承关系用behaves-like-a或is-substitutable-for来表述更准确

➢类型的概念取决于它的行为规范，而非其命名所引发的认知

➢概念抽象只是手段，规范抽象才是依据

➢子类型应该保持或强化超类型的规范

➢子类型不能强化超类型的先验条件，不能弱化超类型的后验条件和类不变量

➢类偏重语法，强调实现方式
类型偏重语义，强调行为方式
类是实现，类型是接口

➢两种分离类的接口与实现的方式：
在语义上通过数据抽象得到接口，在语法上通过封装隐藏实现
在语义上通过多态抽象得到接口，在语法上通过继承隐藏实现

这两对“接口/实现”构成了OOP的主体特征
其中后一对的抽象层次更高
编程应优先针对高层的抽象接口。

➢继承的主要作用：
通过实现继承完成代码重用
通过接口继承完成代码被重用
建立概念的分类体系

慎用继承

里氏替换原则的内容可以描述为：“派生类（子类）对象能够替换其基类（超类）对象被使用。”

继承是一种静态、显性的关系
静态，指关系是在编译期间建立的，且无法在运行期间改变
显性，指关系是公开的，如果通过源代码来改变，将会影响客户代码
这类强耦合关系降低了软件的应变能力，应该尽量规避

与继承相反，合成关系是隐性的，属于内部实现

其一，需要封装的信息不只是内部数据，还包括实现方式和内部逻辑
当一个类通过类继承成为另一个类的子类时，本身就暴露了部分实现方式
从某种意义上说已是一种不完整的封装

其二，子类除了能与父类亲密接触之外
还有一个特权，那就是能覆盖（override）父类的多态方法

继承一个类好比接管一个公司，可以进行业务流程改造，可以增设业务，但不能撤销原有业务
合成一个类好比重组一个公司，可以自由地对原有业务进行整合、改造和剥离

接口继承，只要接口是标准的、稳定的，一般反倒是值得提倡和鼓励的，也是针对接口编程的实践要求

提倡接口继承，慎用实现继承

实现继承最大的硬伤是在类与类之间建立了强耦合关系
使代码趋于僵硬、脆弱和复杂
这种关系是永固的，一经建立无法解除
这种关系是纵深的，不限于相邻的父类与子类，更贯穿整个类族
这种关系还是双向的，从上到下、从下到上
一旦某个类选择了实现继承，就加入了一个大家庭，与它们同呼吸、共命运、休戚相关。从此，该类无法退出此家庭圈

实现继承至少有3处用武之地：
希望访问基础类的protected成员
希望覆盖基础类的方法，并且难以用合成来变通
希望成为基础类的子类型
更实际的建议是，每当为继承与否而举棋不定之时
问自己两个问题：
采用合成是否会遇到无法克服的困难？基础类是否专门为继承而设计？

有些类型是不打算要后代的终极类型，甘作继承树上的绿叶
这种类型在Java中被冠以final修饰符；

另一个极端是，有些类必须被继承，否则不能实例化
从而无法发挥其实例方法（instance method）的作用
例如，有一种类被称为抽象类（abstract class）

如果一个类只有protected的构造器
并且不能通过静态方法来返回实例
那么它也必须靠继承才能应用实例方法

外静指保持外部的接口不变
内动指允许内部的实现变动

大到库、框架、架构等的设计，小到具体的函数、类等的实现，概莫能外

在规范抽象中，静的是功能规范，动的是实现细节
在数据抽象中，静的是API接口，动的是接口实现
在多态抽象中，静的是interface接口，动的是实现类
在非虚接口模式中，静的是非多态的对外接口，动的是多态的对内挂钩

挂钩就是hook，也就是callback回调
借助多态，处于低层的父类调用了处于高层的子类的方法
模板模式父类控制子类父类通过回调达成了对子类的控制反转

设计模式中模板方法（template method）的应用
其基本思想是：
固定基本骨架，同时保留部分可扩展点，使算法既保持足够的坚固性，又不失必要的柔韧性
可谓两全其美。在可扩展点处
父类通过回调达成了对子类的控制反转
模板方法可看作微型框架（micro-framework）模式
正如设计模式可看作微型架构（micro-architecture）模式一样

类的一个公有方法直接或间接地调用了自身的另一个多态方法
如果这种自用只为一时之便，则应尽可能地避免
如果二者的确存在着必然联系，则类的维护者有责任将此联系规范化
以便指导子类正确地覆盖被调方法
同时，尽量让公有的调用方法是非多态的
让多态的被调方法是非公有的
以便分离接口与挂钩的职责，保障代码的健壮性，并减轻子类的实现负担
如此规范与设计双管齐下，一个类才算得上是合格的父类

public访问控制多态的public

public公开接口非多态

protected内部挂钩多态

内部接口protected非多态

自用private非多态

在单继承的机制下，一旦一个类继承了另一个类
便没有机会再继承其他类了
面对这唯一的名额，选择起来自须反复斟酌
与此对照，同时合成多个类是毫无问题的，这再次体现出合成的优势

继承的层次不宜过深
在构造方法中不宜直接或间接地调用多态方法
在克隆（clone）或序列化（serialize）时也需特别谨慎

➢继承是一种静态、显性的关系，合成是一种动态、隐性的关系

➢合成或聚合强调整体与部分之间静态结构上的关系
委托或转发强调表面受理者与实际执行者之间动态功能上的分离
在实际应用中，它们经常但不总是重合的

➢实现继承是灰盒复用，合成是黑盒复用

➢多重（实现）继承通常不被支持或不被提倡，多重合成则不然

➢实现继承破坏封装的途径：访问父类的protected成员、暴露基础类、覆盖父类的方法

➢编程既要保证有意而为的正面效应，又要控制无意而为的负面效应

➢子类在覆盖父类某一方法时
不仅要保证该方法的规范
还要维持相应的关联方法的规范
既不能忽视或破坏父类规范之内的逻辑关联
又不能假设或依赖规范之外的逻辑关联

➢当祖先类不能为后代类提供独立于其实现细节的服务时
前者的封装便被破坏
其改动可能会牵连到后者
造成“脆弱的基类”问题

➢继承是对基础类的兼收并蓄
合成是对基础类的批判继承

➢提倡接口继承
慎用实现继承

➢实现继承最大的硬伤是在类族之间建立了强耦合关系
使代码趋于僵硬、脆弱和复杂

➢非抽象类不适宜作基类

➢为继承而设计的类应该做到：禁用protected域成员
保证protected方法成员的规范性和稳定性
防止覆盖的副作用

➢非多态方法虽然不如多态方法灵活，但更稳定和更可靠
不仅能避免继承带来的安全漏洞和封装破坏
还可能带来性能上的改善

➢正如设计模式可看作微型架构模式
模板方法可看作微型框架模式

➢当类的一个公有方法直接或间接地调用了自身的另一个多态方法时
应特别谨慎
如果不能杜绝这类自用
则必须将其规范化，以免被子类错误地覆盖
此外，应尽量采用非虚接口模式来分离接口与挂钩
让该公有方法不是多态的（接口），让该多态方法不是公有的（挂钩）

➢类的实例方法一般有4种用途（不排除一法多用的可能）
为外界提供服务的公开接口
为子类提供扩展点的内部挂钩
为子类或包提供服务的内部接口
为自身提供服务的私有接口
除内部挂钩外，其他最好是非多态的

➢软件设计应兼顾灵活性与稳定性
提倡外静内动
外静指保持外部的接口不变
内动指允许内部的实现变动
无论是抽象如规范抽象
数据抽象
多态抽象等
还是设计模式如非虚接口模式
模板方法模式等
以及库、框架、架构等的设计
都遵循这个

用合成（composition）组合或复合。