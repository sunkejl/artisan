值与引用

语法类型

从值（value）与引用（reference）谈起
值与引用因其天生的对立性
提供了一个二分法（dichotomy）的准则

它们把数据分成两类：
值——具有某种类型的数据
引用——可用来获取特定数据的值

把变量分成两类：
值变量（value variable）——表示值的变量
引用变量（reference variable）——表示引用的变量

把数据类型分成两类：
值类型（value type）——能直接被访问的数据类型
引用类型（reference type）——借助引用才能被访问的数据类型

把对象分成两类：
值类型对象
引用类型对象


内存分配策略一般都有3种基本机制
按灵活度递增依次为：
静态分配（static allocation）
栈分配（stack allocation）
堆分配（heap allocation）

静态分配发生于编译期
在静态内存区内为全局变量、静态变量、常数变量等安排空间

stack heap
栈分配和堆分配均发生于运行期
stack栈一般在编译期就可确定待分配内存的空间大小和生命周期
heap堆则可能推迟到运行期

栈内存区主要用于存储局部变量（local variable）或自动变量（automatic variable）
堆内存区用于存储由new运算符、malloc函数等动态分配而得的空间

栈分配正是基于简单的堆栈结构(后进先出) 因此效率很高
另外，通常每个线程都有独立的栈区
故而栈变量天然都是线程安全（thread-safe）的

栈的主要缺点是须预知分配内存
而且栈区总容量有限，容易发生栈溢出（stack overflow）
至于栈内存的静态有效期
有时是优点——无需担心内存管理
有时却是缺点——无法突破作用域（scope）
自动释放

再说堆分配，虽然比栈分配更强大、更灵活
但其复杂的算法影响了时间效率
内存碎片（memory fragmentation）、元数据开销（metadata overhead）和可能的内存泄露等问题也影响了空间效率
此外，程序员还需担负更多的内存管理、线程安全等方面的责任
简单与强大、高效与灵活往往是两对难以调和的矛盾
手动释放垃圾回收

如果所需的内存空间较小且较固定，则尽量采用栈分配
如果需要更长的生命周期，则只能采用堆分配
由于堆分配的动态性，分配内存的具体位置和大小一般不能在编译期确定
故不能用值变量直接地表示，而须通过引用变量间接地表示

一个变量是在栈中还是在堆中，
与它是值变量还是引用变量毫不相干
拿Java来说，
局部变量总在栈中，实例变量（instance variable）总在堆中，与变量类型无关

其次，‘被引用的对象总在堆中’的说法在Java和C#中成立
但在C++中则未必——C++也可为栈上的对象创建引用
由于C++只有引用类型的变量，却没有引用类型的对象
因此更保险的说法是：引用类型对象总在堆中

对值变量而言，它对应的是目标数据
对引用变量而言，它对应的不是目标数据本身
而是用来访问目标数据的数据
可以说是一种元数据（metadata）
举例来说，引用最原始的形式是指针（pointer）
任何有效的非空指针对应的数据都是一个内存地址
目标数据的地址

值变量与引用变量的区别不在于它们存放的地点——栈上或堆上，而在于它们存放的内容——数据或地址
在于它们获取目标数据的方式——直接或间接，
在于它们存放目标数据的方式——在线（inline）或离线（offline）

这里的‘在线’指的是：
变量的目标数据在空间上内嵌（embedded）于包含该变量的对象或环境之中

值重在价值，引用重在使用价值

在函数的调用中，需要参数传递
即有一个将实际参数（actual parameter）映射到形式参数（formal parameter）的过程。

最常见有两种机制：
一种是按值传递（pass-by-value或call-by-value），函数收到的是实际参数的值——按位拷贝（bitwise copy）
另一种是按引用传递（pass-by-reference或call-by-reference），函数收到的是实际参数的引用——内存地址

按引用传递一方面，可以保持语言的简单性
另一方面，按引用传递的最大好处是避免产生临时的复制对象，在时空效率上通常优于按值传递

如果Java要达到复制对象值的目的，不能隐式地通过变量赋值或参数传递
只能显式地重新构造对象或通过克隆（clone）、序列化（serialization）等手段
这即是人们常说的值语义（value semantics）与引用语义（reference semantics）的区别


相比按值传递，按引用传递使调用者与被调用者之间的交流更加密切
这种密切有时是多余的，甚至是要回避的
例如，不希望实际参数被方法所改变，但毕竟也有其适用的场合
例如，人们希望通过方法的调用达到下列目的

改变引用变量的目标对象
改变基本类型变量的值
将两个参数参数的值互换（swap）
同时返回多个计算值等等这些都是按值传递无法办到的


分配空间的不连续性浪费读写时间
不连续的空间违背了局部性原理（principle of locality），会增加高速缓存错失（cache miss）的几率
另一不容忽视之处是前面提到的
值类型对象可能分配在栈中，而引用类型对象必须分配在堆中
这表明采用值类型有可能利用栈的优势，进一步提高程序的性能、减少程序员的负担


引用类型的优势，确切说是引用的优势或特点
引用因其间接性和抽象性而带来更大的灵活性
主要表现在：可以避免一些不必要的值拷贝
从而提高效率
当一个对象须要在多处共享同变时，更离不开引用
类似链表、二叉树等这样的递归结构，没有引用也是难以实现的

引用允许为空值（null）
引用不仅是堆分配的必要工具，同时还是实现多态的前提条件

对一个不通过引用而被直接操作的对象来说，多态是不必要的
它的具体类型在编译期间就已确定，动态绑定岂非多此一举？
多态也是不可能的——分配给它的空间无法容纳通常更大的子类型对象

总结➢值与引用为数据、变量、数据类型、对象等提供了二分法。

➢内存分配一般有3种基本机制：静态分配、栈分配和堆分配

➢栈分配的优点是：时空效率较高，无须管理内存，线程安全
缺点是：总容量较小，空间大小和生命周期固定

➢堆分配的优点是：总容量较大，空间大小可动态决定，生命周期较长
缺点是：时空效率较低，须考虑内存管理和线程安全问题

➢引用类型对象总在堆中，值类型对象可能在栈中

➢值变量与引用变量的区别不在于它们存放的地点（栈或堆）
而在于它们存放的内容（数据或地址）、获取目标数据的方式（直接或间接）、存放目标数据的方式（方式（在线或离线）

➢值与引用是相对的，前者重在价值，即本体；后者重在使用价值，即功用

➢按引用传递比按值传递通常有更高的时空效率
为调用者与被调用者提供了更为密切的通讯方式
但须要防止一些实际参数被意外改变。

➢Java是按值传递对象引用，而不是按引用传递对象。C++和C#均提供了按值传递和按引用传递两种机制

➢值类型拥有值语义
引用类型拥有引用语义
它们的差别可以反映在一个变量被一个对象赋值的效果上：前者复制对象的值，后者复制对象的引用

➢值类型是引用类型的基础，并且有一些优势
数据读写更快；创建实例时能节省内存空间和分配次数
数据有可能分配在栈中

➢引用因其间接性和抽象性而比值具有更大的灵活性，主要表现在：
可避免不必要的值拷贝
实现对象共享
容易实现递归结构
堆分配的唯一选择
实现多态的必要条件



语义类型

从命令式编程的角度看，一个值语义变量的内存地址是无关紧要的
原件与复件的唯一差别在被消除后变得完全等价，因而值语义又称复制语义（copy semantics）
相对地，引用语义变量的内存地址至关重要，通常用指针来实现，因而引用语义又称指针语义（pointer semantics）
再从函数式编程的角度看，值应当是引用透明的（referential transparency）
即一个表达式随时可被其值所替换。比如2+3总可用5来代替，“ab”.concat（“cd”）总可用“abcd”来代替。
显然，值的可替换性实质上抹煞了引用的作用。
最后，从对象式编程的角度看，值语义与引用语义的区别在于对象标识（object identity）的重要程度

对象标识是一个对象区别于其他对象的唯一的标识。它是每个对象都具备的一种性质
反映了一个对象作为一个实体的独立性、可识别性和本体性，是对象的3大特征之一
倘若一个对象的标识在程序中没有实际意义，意味着它的对象特征模糊、主体意识淡薄

更多地代表的是一种抽象的属性（attribute）而非一个具体的实体（entity）
则它具有值语义。反之，则具有引用语义


值和引用还有一个差异
值是不依赖于内存地址的，即具有空间无关性。
其实，值通常还具有时间无关性，即一个值语义的对象在其生命周期中的状态是固定的
也就是说，值语义类型一般是不可变的（immutable）

除非特别需要，程序员还是应尽可能地保持字符串对象的不可变性
除了在赋值、按值传递、作为返回值等时凭借值类型的特点来保证字符串的复制以外
还可利用关键词const来保证常量正确性（const-correctness）

引用语义的核心是标识的重要性
关系数据库表（relational database table）
它的每条记录一般都有相应的主键（primary key）作为标识。以此而论，数据库的记录也有引用语义

主键或其他候选键（candidate key）具有逻辑地址的功用，从而使数据库记录有别于单纯的数据集合，与OOP中的对象一样具备引用语义
而表中的属性（attribute）或称字段（field）则具备值语义
于是，值与引用正交地出现在关系数据库中：作为记录的行堪比引用语义对象，作为字段的列堪比值语义类型。

数据模型（data model）与对象模型（object model）
ORM（Object-RelationalMapping）技术的基础也由此奠定

继承层级（inheritance hierarchy）与表之间有多种映射策略，未必是一对一的
如果一个持久化类具有值语义，那么它的对象标识没有意义，相应也不会有数据库标识
因而无法对应一张独立的表，只能嵌入其他表中
这种类在JPA（JavaPersistenceAPI）规范中被称为嵌入类（embedded class）
在Hibernate中被称为组件（component），以区别于直接与表对应的具有引用语义的实体类型（entity type）

采用‘值类型对象’和‘引用类型对象’的术语，而不简称为‘值对象’和‘引用对象’ 是担心产生歧义
因为后两种术语常常被用来代表‘值语义对象’和‘引用语义对象’
尤其是值对象（ValueObject，简称VO），更是常在系统设计中作为通用的术语被使用。
从现在起，除非特别说明，提到的值对象指的都是值语义对象，引用对象指的都是引用语义对象

数据传输对象简称传输对象
多用在基于多层架构（multi-tier architecture）的分布式系统（distributed system）中。
由于不同层（tier）之间的通讯通常会跨越进程（process）或网络（network）的边界
相对昂贵而缓慢的远程调用（remote call）往往成为性能瓶颈
为了减少通讯次数，每次调用应返回尽可能多的数据
欲达此目的，单靠增加调用方法的参数是不够的
那样不仅代码丑陋、难以维护，而且只适用于C++和C#
Java由于不支持按引用传递，无法通过参数来储存返回值

把返回的数据放在数组中这种方法是可行的
但有两大缺点
其一，返回的数据未必是同类型的，而数组和集合的元素一般却是同类型的
如果统一采用Object类型，既不方便又有类型安全隐患
其二，采用这种方式需要按索引（index）、迭代器（iterator）或键（key）来获取返回结果
与按方法或属性来获取结果相比，不仅不直观，还缺乏必要的编译期检查

打包的目的是构造一个粗粒度的数据集合
打包的结果正是传输对象
传输对象只是简单的数据容器，除基本的参数验证和内部一致性校验外不应有其他行为
更不能包含业务逻辑，
至多附加一些必要的序列化（serialization）读写方法
另外，由于传输对象在不同的层之间同时出现
它的域应当只由通用数据类型或其他传输对象组成，这样既便于序列化
又能提高中性度、降低耦合度

第一，从实际用途的角度考察。传输对象的主要目的是携带多项数据以减少网络开销，值对象的主要目的是描述其他对象
第二，从内容传递的角度考察。传输对象因为重视跨层传输而更关心序列化问题，值对象因为重视值语义而更关心赋值问题
第三，从抽象程度的角度考察。传输对象不过是简单的数据载体，数据的透明度高、内聚度低，即使内部结构直接裸露在外也未尝不可

信息隐藏显得可有可无，甚至连getter、setter方法都可省去，丝毫不具备抽象性
以前我们以传输对象作为具体数据类型的代表，便是基于以上理由

反观值对象，它的范畴比传输对象更广，
可以是抽象数据类型，例如字符串、日期等对象

第四，从设计模式的角度考察
传输对象有时是可变的，因为一个传输对象的内容可能需要多步填充或多次更新
值对象则不同，不可变性是一个应尽量遵守的原则，避免产生别名问题而破坏值语义

第五，从对立概念的角度考察
传输对象在实践中常与业务层（business tier）的业务对象（BusinessObject，简称BO）相提并论
业务对象又称领域对象（domain object），是代表业务逻辑或关系的实体
尽管传输对象与业务对象在结构和数据上经常有重合的部分
但一个是具有值语义、具体而短暂的辅助对象，
一个是具有引用语义、抽象而持久的核心对象，具有强烈的对立性
再看值对象，与之对立的概念是引用对象，
在领域驱动设计（domain-driven design，简称DDD）中又称实体（entity）

第六，从表现特征的角度考察
引用对象是数据、运算、标识的三位一体，
值对象则被抽去了标识
而传输对象连运算也被抽去了，只剩下数据
最后，从关注焦点的角度。传输对象的焦点在于‘有什么’，值对象的焦点在于‘是什么’
而引用对象的焦点在于‘是哪个’

首先，标识不等于引用。标识是一种抽象的OOP概念，多用对象建模中
引用是一种具体的语法机制，多用于编码实现中
另外，虽然标识大都通过引用来实现，但也有其他的实现方式
比如通过Java中的数组索引（array index）
其次，引用不等于内存地址
C++中的引用通过指针来实现，指针即内存地址
但Java和C#中的引用则一般不是原始地址（raw address），而是不透明指针（opaque pointer）
以保证内存的安全性
如果牵扯到对象的持久化或序列化问题，情况就更复杂了

通过ORM来获取对象时，相同的主键对应的对象未必有相同的物理地址
再例如一个对象需要跨系统传输，不同机器之间内存地址的比较更是无从谈起
如何协调这类逻辑标识与物理标识之间的矛盾，正是ORM和分布式应用的重要课题之一
我们一直避谈标识的具体实现
强调引用的抽象指代，也是基于这方面的考虑


区分值与引用的意义，不仅体现在语法和语义上，还体现在对象建模上
在设计对象模型时，常用UML类图（class diagram）来描述系统的静态结构
一个类的结构特征是通过性质（property）来表现的
具体来说有两类不同的表示法：属性（attribute）和关联（association）
比如，要设计一个表示人的类（简称‘人类’）
每个人有姓名、生日、家庭地址和工作单位，可以用属性来表示

关联关系可理解为has-a的‘有’关系
如人与工作单位的双向关联——某人有某个工作单位，某工作单位有某些人
聚合（aggregation）是一种强关联，强调整体与部分的关系
可理解为owns-a的‘拥有’关系，如某个部门拥有某些成员
合成（composition）是一种强聚合
可理解为contains-a的‘含有’关系。比如某工作单位含有某些部门

单从代码上看，聚合与关联的界限往往很模糊，而合成关系则比较清晰
实现合成语义至少有两种方法：一种是让被合成的基础类成为值类型或至少实现值语义
另一种是限制外界对被合成对象的访问，并控制它的生命周期
如果合成对象是可持久化的，还要保持数据库的一致性
比如，当删除一个合成对象的记录时，要么事先手工删除被合成对象的记录
要么在数据库的表中或包括ORM在内的框架配置中激活连带删除（cascade delete）选项

继承在概念上虽然是is-a关系，但在物理上也是contains-a关系——子类对象的确隐性含有父类对象。
合成作为继承的替代品，更让这种含有关系暴露无遗，因为合成类显性地把被合成对象作为一个域成员。

从语法和语义的角度看，替代继承的合成与类图中的合成并无区别，
只是前者更侧重语法，后者更侧重语义

只有从对象设计的角度看，才能察觉它们之间真正的差别

➢语法上的值类型可能是语义上的引用类型，语法上的引用类型可能是语义上的值类型

➢值（语义）对象与引用（语义）对象的区别在于：前者的相等性（equality）建立在对象的内容（即各个实例域成员的值）上
后者的相等性建立在对象的标识（identity）上

➢在不影响程序正确性的前提下，一个对象的复件若能代替原件，则该对象的类型是值语义的，否则是引用语义的

➢从命令式编程的角度看，一个值语义变量的内存地址是不重要的
从函数式编程的角度看，值是引用透明的
从对象式编程的角度看，值语义对象的标识是不重要的

➢值语义对象没有标识的概念，对象特征模糊、主体意识淡薄，更多地代表的是属性而非一个实体

➢值通过具体的数据来描述抽象的属性，引用通过抽象的方式来指代具体的实体

➢值语义对象不仅具有空间无关性，还通常具有时间无关性

➢引用类型往往通过不可变性来实现值语义，可变的引用类型往往通过防御性复制来实现值语义

➢不可变性让引用类型具备值语义，不可复制性让值类型具备引用语义

➢抛开底层实现，单从概念上看：值（语义）对象的改变是一种新旧更替，引用（语义）对象的改变是一种自我更新

➢值与引用正交地出现在关系数据库中：作为记录的行堪比引用语义对象，作为字段的列堪比值语义类型

➢数据传输对象是一个粗粒度的数据集合，可以减少方法调用次数，常见于跨进程或网络边界的应用

➢传输对象是一种特殊的值对象

➢标识不等于引用，引用不等于内存地址

➢在UML类图中，类的性质可以用属性或关联来表示。其中，属性偏于值语义，关联偏于引用语义

➢从关联（has-a关系）到聚合（owns-a关系）、再到合成（contains-a关系），耦合度逐步加大
聚合在关联的基础上增加了“整体与部分关系”的语义
合成在聚合的基础上增加了“所有权垄断”和“生存权垄断”的语义

➢关联关系是对称的，并且可以是三元以上的关系；聚合与合成是不对称的，只能是二元关系

➢合成是基于值语义的包含，聚合是基于引用语义的包含

➢从语法和语义上看，替代继承的合成与类图中的合成只是侧重点不同：前者更侧重语法，后者更侧重语义
但从对象设计上看，前者是隐性、动态的关系，后者是显性、静态的关系

➢类与关联是等量齐观的两个要素，在类图中公开重要的关联看似破坏了封装，但与信息隐藏原则并不矛盾

➢实现级别的信息通过访问控制来隐藏，设计级别的信息通过抽象建模来过滤

➢从语法到语义、从设计到实现，处处都贯穿着值与引用这对有体用之分的阴阳两极

OOP中对象的三大特性是：状态（state）、行为（behavior）和标识（identity）

几种不同的映射策略，如：每个具体类一张表；每个类型层级一张表；每个子类一张表

property常常与attribute一样也译为“特性”、“属性”
