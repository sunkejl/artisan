抽象接口



质量低下的软件并不是不能变化，而是在变化面前不能应付裕如。一般表现为：僵硬、敏感而脆弱，一有风吹草动，往往东修西补，难免顾此失彼，甚至如多米诺骨牌般牵一发而动全身，最终不得不推倒重来。正因如此，许多编程设计思想包括OOP的思想都是以提高应变力为主题的，




抽象与封装便是典型代表。抽象一个对象模型即是将一类对象最本质因而最不易变化的部分提炼出来，而封装——准确地说是信息隐藏——则是将非本质、容易变化的部分隐藏起来，



一方面，抽象接口描述了一个类最本质的行为特征；另一方面，具体实现随时可能变动，隐藏它们可以保证这种变动不会波及客户代码。”




“软件的变化大致分两种：一种是出于内在需求而作的结构性变化，通常以改善软件质量为目的，包括代码重构（coderefactoring）、性能调优（performancetuning），等等；一种是出于外在需求而作的功能性变化，通常以满足客户需要为目的。理想的抽象与封装，应能完全避免第一类变化对于客户代码的影响，也能最大限度地降低第二类变化的副作用。



一个非常有用的技巧——柄/体（handle/body）模式或称桥梁模式（bridgepattern），可以将接口与实现完全分开。



接口类实现接口客户类里实例化需要的类进行调用

todo
信息隐藏虽能将抽象接口与具体实现分离，但仍然封装在同一类中。桥梁模式则让二者彻底解耦（decouple），增强了对变化的适应力，具有更大的灵活性和可扩展性。”



“当然这也增加了一定的复杂性和效率上的损失，具体运用时应酌情考量，避免过度设计。”



一个著名的软件原则——开闭原则（open/closedprinciple，简称OCP）[2]。所谓开，指对扩展开放；所谓闭，指对修改封闭。也就是说，软件应该在模块的基础上进行扩展而不是修改。换言之，严格遵循开闭原则的软件，不应该修改老代码，只能增加新代码。”



抽象的模块因稳定而少需修改，因普适而便于扩展，从而更容易符合开闭原则。

越是基础核心越要符合开闭原则类库和框架就是最好的例子，类库提供的服务不能满足要求通过接口interface多态polymorphism继承inheritance合成composition等技巧来扩展相关类

不要修改提供服务的基础代码

➢编程的难点有两个主要方面：逻辑的复杂性和需求的变化性。➢软件质量的一个重要因素是适应变化的能力，这也是许多编程设计思想针对的主题。➢软件的变化主要来自两个方面：一个以改善软件质量为目的的内在结构性变化；一个是以满足客户需要为目的的外在功能性变化。➢信息隐藏屏蔽了一个模块中非本质、容易变化的部分，从而保证内部修改不会波及客户。它的目的是提高软件的应变性和灵活性，而不是安全性。➢信息隐藏能将接口与实现从逻辑上分离，桥梁模式则进一步将二者从物理上分离，从而使代码具有更强的应变能力。在C++中，桥梁模式（也称Pimpl惯用法）还能减少各类之间在编译期的依赖性，从而节省编译链接时间。➢开闭原则（OCP）指软件实体（类、模块、函数等）应对扩展开放、对修改封闭。开闭原则是编程设计（包括OOD）的一个重要准则，对提高软件应变能力尤具指导意义。遵循这一原则的关键在于合理地引入抽象，特别是抽象接口。➢软件可重用性是建立在应变性的基础上的。




　访问控制——代码的多级管理



颔，“访问修饰符（accessmodifier）




“重用是令人兴奋的，合理的重用既节省了开发时间，又节省了维护时间，代码也显得更简洁优美，可谓一举多得。但是——”



一旦所重用的类或方法发生改变，所有的重用者均受牵连，先前节省的时间或许会加倍地偿还。



初级程序员的理想是为所欲为——能用编程解决一切问题；中级程序员的理想是尽善而为——追求最佳解决方案；高级程序员的理想是有所为有所不为——重在整体设计的选择，能抵制局部技巧的诱惑；最高理想是无为而无不为——无论宏观设计还是微观实现，均非刻意选择，却自然合度。”



一个基本原则是尽可能地使用限制性更强的修饰符。即使以后改变主意，再放宽限制也不迟。




静态（static）常量。



为例，每一个public方法成员即是向所有类提供的服务；protected方法成员对该类的子类




服务；private方法成员则只对该类本身提供服务



作为一个抽象数据类型的类，其核心是抽象接口，因此首先应该设计公共接口，它们的修饰符自然都是public。如果该类是一个抽象类（abstractclass）[5]，那么可能会有一些为其子类提供的服务，它们的修饰符自然该是protected。”



从语法上说当然可以。但一般不建议继承非抽象类，



虽然一个类原则上职责应该单一，



对public和protected接口的设计一定是慎之又慎，



客户意识。
客户指软件中间消费者或重用者，即调用该软件的代码，有时也指相应代码的编写者。”



原因。首先，不是每个人都有机会开发大型、关键的软件，许多程序员的客户主要是他自己或少数几个开发组成员，修改软件影响到的代码不多，影响到的人也不多，没有真正吃过设计不当的苦头。其次，开发库和框架的人毕竟是少数，大多数人开发的代码主要是自己调用或直接针对终端消费者的。即使他们







他们写了一些可重用的代码，如果代码质量不被认可，也可能无人采用。当一个人习惯于自弹自唱时，是很难培养客户意识的。最后，正如我们在对象范式中指出的，过程式编程鼓励自顶向下，而OOP鼓励自底向上。显然，顶是底的客户。问题是许多OOP程序员仍习惯于过程式编程的风格，所设计的类主要是调用其他的类或接口，而不是被调用。换句话说，他们设计的代码主要角色是客户，而不是客户的服务者。”



一点：轻诺者，必寡信。




每一个public类、每一个非private成员，都是一份承诺。在没有明确职责、没有准备承担变更后果之前，请采用最严格的访问控制。有了客户意识，才有接口责任感。通过合理地运用访问控制，将类的接口层次化、职责层次化、服务层次化，从而将客户相应地层次化。千万不要为追求廉价的重用而轻易扩大接口范围，莫以自身之便而致客户之不便，莫以一时之便而致长期之不便。另外，单元测试对培养客户意识很有帮助。它不仅仅能发现程序的逻辑缺陷，还能发现程序的设计缺陷。因为测试代码就是最典型的客户代码，它能让你站在客户的角度重新审视自己的接口设计。”



➢选择访问修饰符的基本原则是使类和成员的可访问性极小化。➢除具体数据类型和private内部类的域成员和静态常量域外，域一般都应该用private来修饰。➢原则上，在设计好一个类的接口后，将接口公开，其他的都隐藏。有些抽象类会提供一些protected接口供子类服务。少数用于包内部的接口用包级控制（Java中默认的package、C#中的internal）。➢嵌套类提供了新的类结构层次化的方式。若使用得当，有利于结构的紧凑清晰和信息隐藏。➢C++中一个类与其友类或友函数是联合关系而非主客关系。合理地使用friend修饰符，不仅不会破坏封装，相反能加强封装。➢访问控制划分了抽象的边界，从语义上将抽象层次化，从语法上保护主客双方的代码不受彼此影响。➢访问控制是对静态关联代码的控制，划分了代码修改的边界。➢访问控制使得类的接口层次化、职责层次化、服务层次化、客户层次化。



➢重视培养客户意识和责任感，不可轻诺寡信。➢不要为追求重用而轻易扩大接口范围。



接口服务——





从抽象的角度看，服务的可靠性保证了规范抽象，服务的稳定性保证了数据抽象。”



高质量的服务还要有纯粹性和完备性。Unix有一个哲学：‘一个程序只做一件事，但要做好’。用在OOP上，则是：‘一个类只提供一套服务，但要完善’。



反射机制来间接地访问private成员，更是明显地破坏了封装，属特殊的场合用法。





针对接口编程（programmingtoaninterface），避免针对实现编程（programmingtoanimplementation）。



评委，“OOP系统是对现实社会的模拟，这不仅反映在表现形式上，还反映在行为准则上。它们都是由一些相互交流、相互作用的个体对象组成，个体的品性、行为、能力等参差不齐。





总结➢一个类提供的服务要有可靠性、稳定性、纯粹性和完备性。➢享受类的服务时应遵守规则、遵循规范。➢使用类时应以规范文档为依据，不能以源代码为依据。前者代表抽象接口，后者代表具体实现。如果文档不够明确，应尽可能地与作者通过不断改进的提交文档来交流。➢访问控制只能维护语法上的封装和信息隐藏，而语义上的封装只有靠规范来维护。对程序员来说，前者是一种知识，后者是一种素质。➢如果对象个体都能保证服务的信誉和品质、能遵守服务的规则和规范，就能构建出既可靠又灵活的系统整体。



不要把抽象类与抽象类型或抽象数据类型混为一谈。








